<!DOCTYPE html><html><head>
      <title>CP_9</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
      
      
      
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<p>运行时环境（Runtime Environment）是程序运行时所需的软件环境，它为程序提供必要的系统资源和服务支持。我来详细解释下运行时环境的几个关键方面：</p>
<p>内存管理<br>
运行时环境负责管理程序的内存分配和回收。比如Java运行时会自动进行垃圾回收（GC），而C语言则需要手动管理内存。具体包括堆内存（<code>Heap</code>）、栈内存（<code>Stack</code>）的分配，以及虚拟内存的管理等。</p>
<p>执行环境<br>
提供代码实际运行所需的解释器或虚拟机。像Java需要JRE（<code>Java Runtime Environment</code>），Python需要Python解释器，Node.js需要V8引擎。它们会把源代码转换成机器能理解的指令并执行。</p>
<p>标准库支持<br>
运行时环境通常会提供大量内置的标准库函数。比如Java的<code>java.util</code>包，Python的标准库模块，这些都是运行时环境的组成部分。程序可以直接调用这些库来实现常用功能。</p>
<p>系统接口<br>
为程序提供与操作系统交互的标准接口，处理文件操作、网络通信、进程管理等底层细节。比如Java的<code>System</code>类就封装了许多系统相关的功能。</p>
<p>异常处理<br>
提供异常处理机制，在程序出错时能够捕获并处理各种运行时异常（<code>RuntimeException</code>）。这包括类型错误、空指针、数组越界等各类异常情况。</p>
<p>并发支持<br>
提供线程管理、同步机制等并发编程支持。比如Java运行时就内置了线程池、锁机制、原子操作等并发工具。</p>
<p>需要注意的是，不同编程语言的运行时环境差异很大。像C语言的运行时非常轻量，主要提供启动过程和基础库支持。而Java、Python这样的高级语言则需要更复杂的运行时环境，提供自动内存管理、即时编译等高级特性。</p>
<hr>
<p>ROM（只读存储器）和RAM（随机访问存储器）是两种主要的计算机存储器类型，它们有着完全不同的特点和用途。</p>
<p>ROM的特点：</p>
<ul>
<li>掉电后数据不会丢失，属于非易失性存储器</li>
<li>存储的数据通常是只读的，修改比较困难</li>
<li>读取速度相对较慢</li>
<li>主要用来存储固件（<code>firmware</code>）、BIOS等基础系统程序</li>
<li>常见类型包括：
<ul>
<li><code>PROM</code>：一次性可编程ROM</li>
<li><code>EPROM</code>：可擦除可编程ROM</li>
<li><code>EEPROM</code>：电可擦除可编程ROM</li>
<li><code>Flash ROM</code>：闪存ROM，目前最常用的ROM类型</li>
</ul>
</li>
</ul>
<p>RAM的特点：</p>
<ul>
<li>掉电后数据会丢失，属于易失性存储器</li>
<li>可以随时读写任意地址的数据</li>
<li>读写速度非常快</li>
<li>用作计算机的主存储器，存放正在运行的程序和数据</li>
<li>主要分为两类：
<ul>
<li><code>SRAM</code>（静态RAM）：
<ul>
<li>只要通电就能保持数据</li>
<li>成本高但速度快</li>
<li>常用作CPU缓存</li>
</ul>
</li>
<li><code>DRAM</code>（动态RAM）：
<ul>
<li>需要定期刷新以保持数据</li>
<li>成本低但速度相对较慢</li>
<li>用作主内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在实际应用中，ROM和RAM各自发挥不同作用：ROM负责存储设备的基础程序和配置，保证设备能够正常启动；RAM则作为主存储器，为正在运行的程序提供快速的数据读写支持。两种存储器的配合使用，是现代计算机系统得以正常工作的基础。</p>
<hr>
<p>RAM的内存空间主要分为以下几个区域：</p>
<p>代码段（Text Segment）<br>
存放程序的可执行代码，也叫文本段。这个区域是只读的，防止程序意外修改自身的指令。比如你写的函数<code>main()</code>就会被加载到这里。程序运行时，CPU会从这个区域读取并执行指令。</p>
<p>数据段（Data Segment）<br>
用来存放已初始化的全局变量和静态变量。比如代码中的<code>static int count = 0</code>这样的变量就会存在这里。这个区域的数据在程序启动时就会被加载到内存中。</p>
<p>BSS段（BSS Segment）<br>
存放未初始化的全局变量和静态变量。比如<code>static int arr[1000]</code>这样的变量。系统会将这个区域自动初始化为0，所以它在可执行文件中并不占据实际空间。</p>
<p>堆（Heap）<br>
动态分配的内存区域，由程序员手动管理或由垃圾回收器自动管理。比如C语言中用<code>malloc()</code>分配的内存，或Java中用<code>new</code>创建的对象都在堆上。这个区域从低地址向高地址增长。</p>
<p>栈（Stack）<br>
用于存放函数的局部变量、参数和返回地址。当调用函数时，会在栈上创建一个栈帧。这个区域的内存分配和释放是自动的，并且从高地址向低地址增长。比如：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">// x存储在栈上</span>
<span class="token punctuation">}</span>
</code></pre><p>内存映射区域（Memory Mapping Segment）<br>
用于映射文件或动态链接库到内存空间。这个区域可以让程序直接操作文件内容，也用于加载动态链接库。</p>
<p>这些区域在内存中的排列通常是：代码段在最低地址，然后是数据段和BSS段，接着是堆（向上增长），最后是栈（向下增长）。中间可能会有内存映射区域。</p>
<hr>
<p>常量根据其类型和定义方式会被放在不同的内存区域：</p>
<p>代码段（Text Segment）<br>
字符串常量通常存放在这里。比如代码中直接写的字符串：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>  <span class="token comment">// "hello world"存放在代码段</span>
</code></pre><p>这些字符串是只读的，试图修改它们会导致程序崩溃。</p>
<p>数据段（Data Segment）<br>
存放已初始化的全局常量和静态常量：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-int">int</span> MAX_SIZE <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">// 全局常量，存放在数据段</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-double">double</span> PI <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">;</span>  <span class="token comment">// 静态常量，也在数据段</span>
</code></pre><p>栈（Stack）<br>
局部的const常量会存放在栈上：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-int">int</span> buffer_size <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>  <span class="token comment">// 局部常量，在栈上</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> ch <span class="token operator">=</span> <span class="token char">'A'</span><span class="token punctuation">;</span>  <span class="token comment">// 也在栈上</span>
<span class="token punctuation">}</span>
</code></pre><p>对于C++来说还有一些特殊情况：</p>
<ul>
<li>编译时常量（<code>constexpr</code>）可能会被编译器直接内联到代码中</li>
<li>类中的静态常量成员如果是整型或枚举类型，且在类定义中初始化，那编译器可能不会为它分配实际的存储空间</li>
<li>如果常量的地址被使用（比如取地址操作），编译器就必须为它分配实际的存储空间</li>
</ul>
<hr>
<p>这涉及到编译器优化的一个重要概念。当我们定义一个常量时，编译器会分析它的使用方式，并可能进行优化处理：</p>
<p>编译时替换<br>
比如有这样的代码：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-int">int</span> MAX_SIZE <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> array<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><p>编译器在编译时会直接把<code>MAX_SIZE</code>替换成值100，就像你直接写<code>int array[100]</code>一样。这种情况下，<code>MAX_SIZE</code>这个常量就不需要在运行时占用实际的内存空间，因为它的值已经被"硬编码"到了最终的机器码中。</p>
<p>内联优化<br>
看这个例子：</p>
<pre data-role="codeBlock" data-info="cpp" class="language-cpp cpp"><code><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-double">double</span> PI <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">;</span>
<span class="token keyword keyword-double">double</span> area <span class="token operator">=</span> PI <span class="token operator">*</span> r <span class="token operator">*</span> r<span class="token punctuation">;</span>
</code></pre><p>编译器会直接把<code>PI</code>的值内联到计算表达式中，生成的机器码相当于：</p>
<pre data-role="codeBlock" data-info="cpp" class="language-cpp cpp"><code><span class="token keyword keyword-double">double</span> area <span class="token operator">=</span> <span class="token number">3.14159</span> <span class="token operator">*</span> r <span class="token operator">*</span> r<span class="token punctuation">;</span>
</code></pre><p>这样<code>PI</code>这个常量也不需要占用实际的内存空间。</p>
<p>但有些情况下常量必须分配内存：</p>
<pre data-role="codeBlock" data-info="cpp" class="language-cpp cpp"><code><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-int">int</span> MAX <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>MAX<span class="token punctuation">;</span>  <span class="token comment">// 取常量地址</span>
</code></pre><p>这种情况下，因为我们需要获取常量的内存地址，编译器就必须为这个常量分配实际的存储空间。</p>
<p>再比如全局数组：</p>
<pre data-role="codeBlock" data-info="cpp" class="language-cpp cpp"><code><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-int">int</span> lookup_table<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>这种情况下，即使是常量数组，也需要实际的存储空间来存放这些值。</p>
<p>所以总的来说，编译器会尽可能地优化掉不必要的内存分配，但当程序确实需要访问常量的内存位置时，就必须为其分配实际的存储空间。这就是所谓的"常量折叠"（Constant Folding）优化技术。</p>
<hr>
<p>我来详细讲解下栈（Stack）和堆（Heap）这两种重要的内存区域。</p>
<p>栈内存<br>
栈是一种后进先出（LIFO）的数据结构，由操作系统自动管理分配和释放。特点如下：</p>
<p>在函数调用时会创建栈帧（Stack Frame），包含：</p>
<ul>
<li>函数的局部变量</li>
<li>函数参数</li>
<li>返回地址</li>
<li>上一个栈帧的基指针</li>
</ul>
<p>它的分配过程是这样的：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>      <span class="token comment">// 在栈上分配4字节</span>
    <span class="token keyword keyword-double">double</span> y <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span> <span class="token comment">// 在栈上分配8字节</span>
<span class="token punctuation">}</span>  <span class="token comment">// 函数结束时，自动释放这些内存</span>
</code></pre><p>栈的特点：</p>
<ul>
<li>空间较小（通常是几MB）</li>
<li>分配和释放速度非常快</li>
<li>不会产生内存碎片</li>
<li>空间是连续的</li>
<li>大小在编译时就确定</li>
<li>超出栈空间会导致栈溢出（<code>Stack Overflow</code>）</li>
</ul>
<p>堆内存<br>
堆是用于动态内存分配的区域，需要手动管理或依赖垃圾回收。看个例子：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 在堆上分配4000字节</span>
<span class="token comment">// 使用完需要手动释放</span>
<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>在Java中是这样：</p>
<pre data-role="codeBlock" data-info="java" class="language-java java"><code><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 在堆上分配对象</span>
<span class="token comment">// 不需要手动释放，由GC处理</span>
</code></pre><p>堆的特点：</p>
<ul>
<li>空间较大（可以到GB级别）</li>
<li>分配和释放速度相对较慢</li>
<li>可能产生内存碎片</li>
<li>空间不一定连续</li>
<li>大小可以动态调整</li>
<li>容易产生内存泄漏问题</li>
</ul>
<p>内存管理的差异：</p>
<ol>
<li>
<p>C语言中：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 栈内存</span>
<span class="token keyword keyword-int">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 编译时确定大小</span>

<span class="token comment">// 堆内存</span>
<span class="token keyword keyword-int">int</span><span class="token operator">*</span> arr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 运行时动态分配</span>
</code></pre></li>
<li>
<p>Java中：</p>
<pre data-role="codeBlock" data-info="java" class="language-java java"><code><span class="token comment">// 栈内存</span>
<span class="token keyword keyword-int">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">// 基本类型的局部变量</span>

<span class="token comment">// 堆内存</span>
<span class="token class-name">Integer</span> y <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 对象总是在堆上</span>
</code></pre></li>
</ol>
<p>选择建议：</p>
<ul>
<li>小型、固定大小的数据，优先使用栈</li>
<li>大型、动态大小的数据，使用堆</li>
<li>需要在函数间共享的数据，使用堆</li>
<li>关注性能的场景，尽量使用栈</li>
<li>需要灵活管理生命周期的数据，使用堆</li>
</ul>
<p>这两种内存区域各有特点，在实际编程中要根据具体需求选择合适的存储位置。理解它们的区别和特点，对于写出高效且健壮的代码非常重要。</p>
<hr>
<p>让我详细讲解函数调用的完整过程。</p>
<p>函数调用准备<br>
当遇到函数调用指令时，系统会先进行调用前的准备工作：</p>
<ol>
<li>
<p>参数压栈<br>
按照调用约定（<code>calling convention</code>）将参数压入栈中。通常是从右向左压栈：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> a<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 调用时：add(3, 5)</span>
<span class="token comment">// 先压入5，再压入3</span>
</code></pre></li>
<li>
<p>保存返回地址<br>
将调用指令的下一条指令地址压栈，这样函数执行完才知道返回到哪里继续执行。</p>
</li>
</ol>
<p>栈帧的创建和初始化：</p>
<ol>
<li>
<p>保存旧的帧指针<br>
把当前的帧指针（<code>EBP</code>/<code>RBP</code>）压栈，用于后续恢复。</p>
</li>
<li>
<p>建立新的栈帧<br>
将栈指针（<code>ESP</code>/<code>RSP</code>）的值赋给帧指针，建立新的栈帧基址。</p>
</li>
<li>
<p>分配局部变量空间<br>
移动栈指针，为局部变量预留空间：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> x<span class="token punctuation">;</span>      <span class="token comment">// 在栈上分配4字节</span>
    <span class="token keyword keyword-char">char</span> str<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 在栈上分配8字节</span>
<span class="token punctuation">}</span>
</code></pre></li>
</ol>
<p>函数执行过程：</p>
<ol>
<li>
<p>指令执行<br>
CPU开始执行函数体中的指令，可以通过帧指针访问参数和局部变量：</p>
<ul>
<li>向上访问参数：<code>[ebp+8]</code>、<code>[ebp+12]</code>等</li>
<li>向下访问局部变量：<code>[ebp-4]</code>、<code>[ebp-8]</code>等</li>
</ul>
</li>
<li>
<p>寄存器使用<br>
函数可能会使用各种寄存器进行计算，有些寄存器需要保存和恢复：</p>
<ul>
<li>易失寄存器：可以随意使用</li>
<li>非易失寄存器：使用前要保存，使用后要恢复</li>
</ul>
</li>
</ol>
<p>函数返回过程：</p>
<ol>
<li>
<p>准备返回值<br>
将返回值存入指定寄存器（通常是<code>EAX</code>/<code>RAX</code>）：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">42</span><span class="token punctuation">;</span>  <span class="token comment">// 42被存入EAX</span>
<span class="token punctuation">}</span>
</code></pre></li>
<li>
<p>栈帧清理</p>
<ul>
<li>恢复栈指针</li>
<li>恢复原来的帧指针</li>
<li>弹出返回地址</li>
</ul>
</li>
<li>
<p>跳转返回<br>
根据之前保存的返回地址，跳转回调用点继续执行。</p>
</li>
</ol>
<p>递归调用的特殊情况：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">recursive</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">recursive</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 每次递归都会创建新的栈帧</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>在递归调用中，每次函数调用都会创建新的栈帧，如果递归层次太深，可能导致栈溢出。</p>
<p>函数调用优化：</p>
<ul>
<li>尾递归优化：编译器可能会将尾递归转换为循环</li>
<li>内联优化：直接将函数代码插入调用处，避免函数调用开销</li>
<li>寄存器传参：通过寄存器传递参数，减少栈操作</li>
</ul>
<hr>
<p>好的，让我用一个具体的例子，一步步演示函数调用的过程。假设我们有这样一段代码：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> a<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> result <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> z <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>让我们看看调用<code>add(x, y)</code>时发生了什么：</p>
<ol>
<li>
<p>参数准备和压栈</p>
<pre data-role="codeBlock" data-info="x86asm" class="language-x86asm x86asm"><code>push 5    ; y的值压栈
push 3    ; x的值压栈
</code></pre><p>此时栈的状态：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>栈顶→ [3]     ; x参数
      [5]     ; y参数
      [...其他数据]
</code></pre></li>
<li>
<p>保存返回地址并跳转</p>
<pre data-role="codeBlock" data-info="x86asm" class="language-x86asm x86asm"><code>call add  ; 将下一条指令地址压栈，然后跳转到add函数
</code></pre><p>此时栈的状态：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>栈顶→ [返回地址] ; 调用指令的下一条指令地址
      [3]      ; x参数
      [5]      ; y参数
      [...其他数据]
</code></pre></li>
<li>
<p>创建add函数的栈帧</p>
<pre data-role="codeBlock" data-info="x86asm" class="language-x86asm x86asm"><code>push ebp         ; 保存旧的帧指针
mov ebp, esp     ; 建立新的栈帧基址
sub esp, 4       ; 为局部变量result分配空间
</code></pre><p>此时栈的状态：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>栈顶→ [未初始化的空间] ; result的位置
      [旧的ebp]      ; 保存的帧指针
      [返回地址]      ; 返回地址
      [3]           ; 参数a
      [5]           ; 参数b
      [...其他数据]
</code></pre></li>
<li>
<p>执行函数体</p>
<pre data-role="codeBlock" data-info="x86asm" class="language-x86asm x86asm"><code>mov eax, [ebp+8]    ; 取参数a的值（3）
add eax, [ebp+12]   ; 加上参数b的值（5）
mov [ebp-4], eax    ; 将结果存入result
</code></pre></li>
<li>
<p>准备返回</p>
<pre data-role="codeBlock" data-info="x86asm" class="language-x86asm x86asm"><code>mov eax, [ebp-4]   ; 将result的值放入eax作为返回值
mov esp, ebp       ; 恢复栈指针
pop ebp            ; 恢复帧指针
ret               ; 弹出返回地址并跳转
</code></pre></li>
<li>
<p>清理栈并继续执行<br>
回到<code>main</code>函数后，需要清理之前压入的参数：</p>
<pre data-role="codeBlock" data-info="x86asm" class="language-x86asm x86asm"><code>add esp, 8        ; 清理两个参数（每个4字节）
mov [z], eax      ; 将返回值存入变量z
</code></pre></li>
</ol>
<p>整个过程的内存变化可以这样表示：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>调用前的main栈帧：
栈顶→ [x=3]
      [y=5]
      [main的帧指针]
      [main的返回地址]

调用add后：
栈顶→ [result]
      [add的帧指针]
      [返回地址]
      [a=3]
      [b=5]
      [x=3]
      [y=5]
      [main的帧指针]
      [main的返回地址]

返回后的main栈帧：
栈顶→ [x=3]
      [y=5]
      [z=8]
      [main的帧指针]
      [main的返回地址]
</code></pre><p>这个例子展示了函数调用过程中栈的变化。每个函数调用都会创建这样的栈帧结构，确保函数能够正确访问自己的参数和局部变量，并在返回时恢复调用者的执行环境。</p>
<hr>
<p>啊这样，让我解释下<code>ebp</code>和<code>esp</code>这两个关键的寄存器，以及它们在函数调用中的作用。</p>
<p><code>esp</code>（Stack Pointer）是栈指针寄存器：</p>
<ul>
<li>永远指向栈顶位置</li>
<li>当我们<code>push</code>数据时，<code>esp</code>会减小（因为栈从高地址向低地址增长）</li>
<li>当我们<code>pop</code>数据时，<code>esp</code>会增大</li>
</ul>
<p><code>ebp</code>（Base Pointer）是帧指针寄存器：</p>
<ul>
<li>指向当前函数栈帧的基准位置</li>
<li>通过<code>ebp</code>可以方便地访问函数的参数和局部变量</li>
<li>函数的参数在<code>ebp</code>上方（地址比<code>ebp</code>大）</li>
<li>局部变量在<code>ebp</code>下方（地址比<code>ebp</code>小）</li>
</ul>
<p>让我们看看这段代码在做什么：</p>
<pre data-role="codeBlock" data-info="x86asm" class="language-x86asm x86asm"><code>; 假设当前在main函数中，即将调用add函数
; ebp指向main函数的栈帧基址
; esp指向栈顶

push ebp         ; 把main函数的ebp保存到栈上
                 ; 这样add函数结束时才能恢复回main的栈帧
                 ; 执行后esp会减小4个字节

mov ebp, esp     ; 把当前的栈顶位置保存在ebp中
                 ; 这样就建立了add函数的新栈帧基址
                 ; 后续可以用ebp来访问参数和局部变量

sub esp, 4       ; 把esp往下移动4字节
                 ; 为add函数的局部变量result预留空间
</code></pre><p>画个图来说明这个过程：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>调用前：
高地址→ [......]
        [参数b]   ←[ebp+12]
        [参数a]   ←[ebp+8]
        [返回地址] ←[ebp+4]
        [旧ebp]   ←ebp指向这里
        [局部变量] ←[ebp-4]
低地址→ [......]  ←esp指向这里

例如：
要访问参数a：mov eax, [ebp+8]
要访问局部变量：mov eax, [ebp-4]
</code></pre><p>为什么要这么设计？</p>
<ol>
<li>如果直接用<code>esp</code>访问数据会很麻烦，因为<code>esp</code>会随着<code>push</code>和<code>pop</code>操作不断变化</li>
<li>而<code>ebp</code>在函数执行期间保持不变，可以用固定的偏移量访问数据</li>
<li>保存旧的<code>ebp</code>是为了函数返回时能恢复回调用者的栈帧</li>
</ol>
<p>这就像是在一摞书中：</p>
<ul>
<li><code>esp</code>就像是你的手指，总是指着最上面的书</li>
<li><code>ebp</code>就像是一个书签，标记着当前这本书的位置</li>
<li>当你要读新的一本书时，要先把之前书的书签位置记下来（<code>push ebp</code>）</li>
<li>然后把书签放在新的位置（<code>mov ebp, esp</code>）</li>
<li>最后给新书预留一些空白页做笔记（<code>sub esp, 4</code>）</li>
</ul>
<hr>
<p>好，让我解释函数返回时是如何恢复的。还是用刚才的例子：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> a<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> result <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>当函数要返回时，栈的状态是这样的：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>高地址→ [参数b=5]   ←[ebp+12]
        [参数a=3]   ←[ebp+8]
        [返回地址]   ←[ebp+4]
        [main的ebp] ←ebp指向这里
        [result=8]  ←[ebp-4]
低地址→ [.........]  ←esp指向这里
</code></pre><p>返回过程的代码是这样的：</p>
<pre data-role="codeBlock" data-info="x86asm" class="language-x86asm x86asm"><code>mov eax, [ebp-4]    ; 把result的值（8）放入eax作为返回值
mov esp, ebp        ; 把esp移回ebp的位置，相当于释放了局部变量的空间
pop ebp             ; 从栈顶弹出保存的main函数的ebp值
                    ; 这条指令会让esp向上移动4字节
ret                 ; 弹出返回地址并跳转回去
                    ; 这条指令也会让esp向上移动4字节
</code></pre><p>执行完这些指令后：</p>
<ol>
<li><code>eax</code>寄存器里存着返回值8</li>
<li><code>ebp</code>恢复成了<code>main</code>函数的帧指针</li>
<li>程序跳回了<code>main</code>函数的调用点继续执行</li>
<li><code>esp</code>指向了参数<code>a</code>的位置</li>
</ol>
<p>最后在<code>main</code>函数中还要清理压入的参数：</p>
<pre data-role="codeBlock" data-info="x86asm" class="language-x86asm x86asm"><code>add esp, 8          ; esp向上移动8字节，跳过两个参数
mov [z], eax        ; 把返回值存入变量z
</code></pre><p>这就像是：</p>
<ol>
<li>把笔记内容（返回值）记在小纸条上（<code>eax</code>寄存器）</li>
<li>合上当前的书（清理局部变量）</li>
<li>拿出之前的书签（恢复<code>main</code>的<code>ebp</code>）</li>
<li>跳回原来读到的地方（返回地址）</li>
<li>把用完的草稿纸（参数）扔掉</li>
</ol>
<p>这样就完整地完成了函数的调用和返回过程，把控制权还给了调用者，并且保证了各自的栈帧都能正确处理。</p>
<hr>
<blockquote>
<p>题目七：设有如下C语言程序：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token number">1</span> #include <span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
<span class="token number">2</span> 
<span class="token number">3</span> <span class="token keyword keyword-void">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token number">4</span> <span class="token punctuation">{</span>
<span class="token number">5</span>   <span class="token keyword keyword-char">char</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Stay"</span><span class="token punctuation">,</span> <span class="token string">"Safe"</span><span class="token punctuation">,</span> <span class="token string">"From"</span><span class="token punctuation">,</span> <span class="token string">"Covid"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token number">6</span>   <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token number">7</span>     s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token number">8</span> <span class="token punctuation">}</span>
<span class="token number">9</span> 
<span class="token number">10</span> <span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">11</span> <span class="token punctuation">{</span>
<span class="token number">12</span>   <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token number">13</span>   <span class="token function">init</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">14</span>   <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token number">15</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">16</span>   <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token number">17</span> <span class="token punctuation">}</span>
</code></pre><p>该程序在Intel x86/Linux下用gcc编译没有任何警告，但运行编译后的程序输出乱码：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>Ha}HEJ IH ...
</code></pre><p>但若把第5行修改为：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Stay"</span><span class="token punctuation">,</span> <span class="token string">"Safe"</span><span class="token punctuation">,</span> <span class="token string">"From"</span><span class="token punctuation">,</span> <span class="token string">"Covid"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>则程序可正确地输出：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>StaySafeFromCovid
</code></pre><p>试分析产生运行错误的原因。</p>
</blockquote>
<p>啊，这是个很经典的问题，涉及到局部变量的生命周期和数组的存储位置。让我解释下为什么会这样。</p>
<p>第一种写法（错误的）：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Stay"</span><span class="token punctuation">,</span> <span class="token string">"Safe"</span><span class="token punctuation">,</span> <span class="token string">"From"</span><span class="token punctuation">,</span> <span class="token string">"Covid"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 存在栈上</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 把栈上的地址复制给s</span>
<span class="token punctuation">}</span>  <span class="token comment">// 函数返回时a被释放</span>
</code></pre><p>这里的问题是：</p>
<ol>
<li><code>char a[][8]</code>是在函数<code>init</code>的栈帧上分配的局部数组</li>
<li>当把<code>a[i]</code>赋值给<code>s[i]</code>时，复制的是字符串在栈上的地址</li>
<li>函数返回时，这些字符串所在的栈空间就被释放了</li>
<li>所以<code>main</code>函数里打印时，访问的是已经失效的内存地址</li>
</ol>
<p>第二种写法（正确的）：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Stay"</span><span class="token punctuation">,</span> <span class="token string">"Safe"</span><span class="token punctuation">,</span> <span class="token string">"From"</span><span class="token punctuation">,</span> <span class="token string">"Covid"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 字符串字面量存在只读段</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 把只读段的地址复制给s</span>
<span class="token punctuation">}</span>
</code></pre><p>这种写法工作正常是因为：</p>
<ol>
<li><code>char *a[]</code>中的字符串字面量被编译器存储在程序的只读数据段</li>
<li><code>a</code>数组存的是指向这些字符串字面量的指针</li>
<li>虽然<code>a</code>数组本身还是在栈上，但它指向的字符串在只读段上</li>
<li>所以函数返回后，这些字符串依然有效</li>
</ol>
<p>让我画个图说明内存布局：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>第一种写法的内存布局：
              +——————————————+
只读段         |              |
              +——————————————+
              |              |
数据段         |              |
              +——————————————+
              | "Stay\0###"  |  &lt;— 这些字符串在init函数
栈（init函数）  | "Safe\0###"  |    的栈帧上，函数返回
              | "From\0###"  |    时会被释放
              | "Covid\0##"  |
              +——————————————+
              | s[0]→???    |  &lt;— main函数的s数组
栈（main函数）  | s[1]→???    |    指向的是已经失效
              | s[2]→???    |    的栈内存
              | s[3]→???    |
              +——————————————+

第二种写法的内存布局：
              +——————————————+
              | "Stay\0"     |  &lt;— 字符串字面量
只读段         | "Safe\0"     |    存在这里，程序
              | "From\0"     |    运行期间一直存在
              | "Covid\0"    |
              +——————————————+
              |              |
数据段         |              |
              +——————————————+
              | ptr→"Stay"   |  &lt;— init函数的a数组
栈（init函数）  | ptr→"Safe"   |    存的是指向只读段
              | ptr→"From"   |    的指针
              | ptr→"Covid"  |
              +——————————————+
              | s[0]→"Stay"  |  &lt;— main函数的s数组
栈（main函数）  | s[1]→"Safe"  |    复制的是指向只读段
              | s[2]→"From"  |    的指针
              | s[3]→"Covid" |
              +——————————————+
</code></pre><p>这个例子很好地说明了要注意不要返回局部变量的地址，因为局部变量在函数返回时会被释放。如果需要返回数据，要么使用动态分配的内存（堆），要么像第二种写法那样利用字符串字面量的特性。</p>
<hr>
<blockquote>
<p>我还是不太明白，为什么说这两种写法会被放在不同位置？能详细解释下字符串字面量的存储方式，以及这两种声明的区别吗？</p>
</blockquote>
<p>字符串字面量（如<code>"Stay"</code>）总是存储在程序的只读段中，但两种声明方式会导致完全不同的内存使用方式：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 第一种：字符数组的数组</span>
<span class="token keyword keyword-char">char</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Stay"</span><span class="token punctuation">,</span> <span class="token string">"Safe"</span><span class="token punctuation">,</span> <span class="token string">"From"</span><span class="token punctuation">,</span> <span class="token string">"Covid"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 第二种：字符指针的数组</span>
<span class="token keyword keyword-char">char</span> <span class="token operator">*</span>a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Stay"</span><span class="token punctuation">,</span> <span class="token string">"Safe"</span><span class="token punctuation">,</span> <span class="token string">"From"</span><span class="token punctuation">,</span> <span class="token string">"Covid"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>第一种写法：</p>
<ul>
<li><code>char a[][8]</code>声明的是一个二维字符数组</li>
<li>编译器会在栈上分配<code>4*8=32</code>字节的空间</li>
<li>字符串字面量的内容会被复制到这个栈空间中</li>
<li>相当于：<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-char">char</span> a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 从只读段复制到栈上</span>
<span class="token function">strcpy</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"Stay"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">strcpy</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"Safe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">strcpy</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"From"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">strcpy</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"Covid"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></li>
</ul>
<p>第二种写法：</p>
<ul>
<li><code>char *a[]</code>声明的是指针数组</li>
<li>数组<code>a</code>中直接存放指向只读段中字符串的指针</li>
<li>相当于：<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// a数组在栈上</span>
<span class="token keyword keyword-char">char</span> <span class="token operator">*</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 直接使用只读段的地址</span>
a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token string">"Stay"</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 相当于a[0] = "Stay"</span>
a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token string">"Safe"</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token string">"From"</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token string">"Covid"</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></li>
</ul>
<p>我们可以用代码验证这个区别：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword keyword-void">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Stay"</span><span class="token punctuation">,</span> <span class="token string">"Safe"</span><span class="token punctuation">,</span> <span class="token string">"From"</span><span class="token punctuation">,</span> <span class="token string">"Covid"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"test1中：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a[%d]的地址: %p\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a[%d]的内容: %s\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印实际内存内容</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"内存内容: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%02X "</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-char">char</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Stay"</span><span class="token punctuation">,</span> <span class="token string">"Safe"</span><span class="token punctuation">,</span> <span class="token string">"From"</span><span class="token punctuation">,</span> <span class="token string">"Covid"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"test2中：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a[%d]指向的地址: %p\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a[%d]的内容: %s\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印实际内存内容</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"内存内容: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%02X "</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-char">char</span><span class="token punctuation">)</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"00\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><pre data-role="codeBlock" data-info="cmd" class="language-cmd cmd"><code>test1中：
a[0]的地址: 000000000061FDC0
a[0]的内容: Stay
内存内容: 53 74 61 79 00 00 00 00

a[1]的地址: 000000000061FDC8
a[1]的内容: Safe
内存内容: 53 61 66 65 00 00 00 00

a[2]的地址: 000000000061FDD0
a[2]的内容: From
内存内容: 46 72 6F 6D 00 00 00 00

a[3]的地址: 000000000061FDD8
a[3]的内容: Covid
内存内容: 43 6F 76 69 64 00 00 00


test2中：
a[0]指向的地址: 000000000040404B
a[0]的内容: Stay
内存内容: 53 74 61 79 00

a[1]指向的地址: 0000000000404050
a[1]的内容: Safe
内存内容: 53 61 66 65 00

a[2]指向的地址: 0000000000404055
a[2]的内容: From
内存内容: 46 72 6F 6D 00

a[3]指向的地址: 000000000040405A
a[3]的内容: Covid
内存内容: 43 6F 76 69 64 00
</code></pre><p>运行这段代码，可以看到关键区别：</p>
<ol>
<li><code>test1</code>中的地址在栈上（如<code>0x62FDC0</code>），每个元素间隔8字节（我们声明的数组大小），包含了用<code>\0</code>填充的未使用空间</li>
<li><code>test2</code>中的地址在代码段/只读段（如<code>0x405021</code>），每个元素间隔大约是字符串实际长度+1，只包含实际需要的空间</li>
</ol>
<p>这就解释了为什么原始程序中第一种写法会出问题：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Stay"</span><span class="token punctuation">,</span> <span class="token string">"Safe"</span><span class="token punctuation">,</span> <span class="token string">"From"</span><span class="token punctuation">,</span> <span class="token string">"Covid"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// ⚠️ 把栈上的地址给了s</span>
<span class="token punctuation">}</span>   <span class="token comment">// 函数返回时这些栈上的内容就没了</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">init</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// s里存的是已经失效的栈地址</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 访问失效的内存，输出垃圾值</span>
<span class="token punctuation">}</span>
</code></pre><p>而第二种写法能正常工作：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Stay"</span><span class="token punctuation">,</span> <span class="token string">"Safe"</span><span class="token punctuation">,</span> <span class="token string">"From"</span><span class="token punctuation">,</span> <span class="token string">"Covid"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// ✅ 把只读段的地址给了s</span>
<span class="token punctuation">}</span>   <span class="token comment">// 函数返回后只读段的内容依然存在</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">init</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// s里存的是只读段中字符串的地址</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 正常访问只读段的内容</span>
<span class="token punctuation">}</span>
</code></pre><p>这就是两种写法在内存使用上的本质区别，也解释了为什么第一种写法会导致程序出错，而第二种写法能够正常工作。</p>
<hr>
<blockquote>
<p>七、设有如下C语言程序：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>dest<span class="token punctuation">;</span>
   dest <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       dest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>src<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       i<span class="token operator">++</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token keyword keyword-return">return</span> dest<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword keyword-char">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"Class 2017"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
   <span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>dest<span class="token punctuation">;</span>
   dest <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> dest<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>该程序希望复制一个字符串数组，并输出拷贝后的数组。在Intel x86/Linux下用<code>gcc</code>编译没有任何警告，但运行编译后的程序报"Segmentation fault"。</p>
<p>但若把程序的第19行修改为：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"Class 2017"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>则程序工作正常，即在输出以下字符串后正常退出：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>Hello
Class 2017
</code></pre><p>试问上述程序产生运行错误的原因。</p>
</blockquote>
<p>啊，这又是一个类似的字符数组和字符指针数组的问题。让我解释下为什么会出现段错误：</p>
<p>第一种写法（有问题的）：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-char">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"Class2017"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
dest <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ⚠️ 这里的类型转换是危险的</span>
</code></pre><p>这里的问题在于：</p>
<ol>
<li><code>s</code>是一个二维字符数组，占用连续的<code>2*20=40</code>字节空间</li>
<li>在栈上的内存布局是这样的：<pre data-role="codeBlock" data-info="" class="language-text"><code>s[0]: ['H','e','l','l','o','\0','\0',...(20字节)]
s[1]: ['C','l','a','s','s',...,'\0',...(20字节)]
</code></pre></li>
<li>当把<code>s</code>强制转换为<code>char**</code>时，程序会把这片内存当作指针数组来读</li>
<li>但实际上这些内存位置存的是字符而不是指针，所以访问时会导致段错误</li>
</ol>
<p>第二种写法（正确的）：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"Class2017"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
dest <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ✅ 这里的转换是安全的</span>
</code></pre><p>这种写法正确，因为：</p>
<ol>
<li><code>s</code>是指针数组，存放的就是指向字符串的指针</li>
<li>内存布局是这样的：<pre data-role="codeBlock" data-info="" class="language-text"><code>s[0]: 指向"Hello"的指针
s[1]: 指向"Class2017"的指针
</code></pre></li>
<li>这种情况下转换为<code>char**</code>是合理的，因为本来就是存储的指针</li>
</ol>
<p>让我们修改代码来看看具体的内存布局：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword keyword-void">void</span> <span class="token function">print_memory</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> addr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> p <span class="token operator">=</span> addr<span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%02X "</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 第一种写法</span>
    <span class="token keyword keyword-char">char</span> s1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"Class2017"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"s1的内存内容：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print_memory</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 第二种写法</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"Class2017"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\ns2的内存内容：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print_memory</span><span class="token punctuation">(</span>s2<span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><pre data-role="codeBlock" data-info="cmd" class="language-cmd cmd"><code>s1的内存内容：
48 65 6C 6C 6F 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 43 6C 61 73 
73 32 30 31 37 00 00 00 
00 00 00 00 00 00 00 00 


s2的内存内容：
1B 40 40 00 00 00 00 00
21 40 40 00 00 00 00 00
</code></pre><p>所以原始程序出错的根本原因是：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-char">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"Class2017"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
dest <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 把字符数组强制转换成字符指针数组</span>

<span class="token comment">// 在foo函数中</span>
dest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>src<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// src[i]被当作指针使用</span>
                            <span class="token comment">// 但实际上它指向的是无效地址</span>
                            <span class="token comment">// 因为原数组存的是字符而不是指针</span>
</code></pre><p>要修复这个问题，除了改用<code>char *s[]</code>的声明方式外，还可以这样改：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 修改foo函数的参数类型</span>
<span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token punctuation">(</span><span class="token operator">*</span>src<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> n<span class="token punctuation">)</span>  <span class="token comment">// 明确指出是二维数组</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>dest <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>src<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// src[i]现在正确地指向每行的起始位置</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> dest<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"Class2017"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>dest <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 不需要类型转换</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><p>这个例子很好地说明了为什么在C语言中要特别注意指针类型的转换，尤其是在处理字符串和数组时。不正确的类型转换可能在编译时不会报错，但在运行时会导致严重的问题。</p>
<p><strong>补充知识1</strong></p>
<p>让我详细解释一下这个形式参数的写法<code>char (*src)[20]</code>。</p>
<p>首先要明白数组跟指针的区别。在这个问题里，<code>char s[][20]</code>是一个二维数组，等价于<code>char [2][20]</code>，意思是这个数组有2行，每行20个字符。也就是说这是一块连续的内存，一共<code>2×20=40</code>个字符。</p>
<p><code>char (*src)[20]</code>是一个指向数组的指针，具体来说是指向"长度为20的字符数组"的指针。这跟<code>char **src</code>是不一样的：</p>
<ul>
<li><code>char **src</code>是指向"字符指针"的指针，每个元素是一个指针</li>
<li><code>char (*src)[20]</code>是指向"字符数组"的指针，每个元素是一个长度为20的数组</li>
</ul>
<p>我们可以用一段代码来演示它们的区别：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword keyword-void">void</span> <span class="token function">foo1</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"指针1：%p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"指针2：%p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">foo2</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token punctuation">(</span><span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"数组1起始地址：%p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"数组2起始地址：%p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 第一种：字符指针数组</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"=== 第一种情况 ===\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">foo1</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 第二种：二维字符数组</span>
    <span class="token keyword keyword-char">char</span> s2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n=== 第二种情况 ===\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">foo2</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>在第一种情况下，<code>s1</code>里存的是两个指针，这两个指针分别指向字符串<code>"Hello"</code>和<code>"World"</code>所在的内存位置（通常在只读数据段）。</p>
<p>在第二种情况下，<code>s2</code>本身就存着这些字符，比如<code>s2[0]</code>就直接是<code>{'H','e','l','l','o','\0',...}</code>这样一个数组，<code>s2[1]</code>则是另一个数组。所以<code>s2[0]</code>和<code>s2[1]</code>的地址差是20个字节。</p>
<p>所以在最初的那个问题中，把<code>char s[][20]</code>强制转换成<code>char **</code>是错误的，因为程序会把字符数据当成指针来用。修改后的代码用<code>char (*src)[20]</code>声明参数，就能正确地按照二维数组的方式来访问数据。</p>
<p>理解这些概念的关键在于：</p>
<ol>
<li><code>char **</code>是"指向字符指针的指针"</li>
<li><code>char (*)[20]</code>是"指向长度为20的字符数组的指针"</li>
<li>前者的结构是离散的（每个字符串可能在内存的不同位置）</li>
<li>后者的结构是连续的（所有字符都在一块连续的内存中）</li>
</ol>
<p><strong>补充知识2</strong></p>
<p>有的哦！事实上<code>char *s[20]</code>跟<code>char (*s)[20]</code>是完全不同的东西呢。</p>
<p><code>char *s[20]</code>是一个数组，这个数组里存了20个指针，每个指针都指向一个字符串。我们一般用这种方式来存储多个字符串。比如：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>names<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token string">"Carol"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 存储3个名字的数组</span>
</code></pre><p>而<code>char (*s)[20]</code>是一个指针，它指向一个"长度为20的字符数组"。有点绕是不是？不过配合之前的解释，我们可以这样想：</p>
<ul>
<li><code>char *s[20]</code>：这是20个<code>char*</code>（有20支箭）</li>
<li><code>char (*s)[20]</code>：这是1个<code>char (*)[20]</code>（有1支箭指向一块连续的内存）</li>
</ul>
<p>举个例子：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 第一种：指针数组</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s1<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 可以存20个字符串</span>
    s1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>
    s1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"World"</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"s1[0]是%s\n"</span><span class="token punctuation">,</span> s1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 第二种：指向数组的指针</span>
    <span class="token keyword keyword-char">char</span> arr<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>  <span class="token comment">// 一个长度为20的字符数组</span>
    <span class="token keyword keyword-char">char</span> <span class="token punctuation">(</span><span class="token operator">*</span>s2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">;</span>   <span class="token comment">// s2指向这个数组</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"(*s2)是%s\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>啊，说到这我想起来一个经常让人迷惑的地方。在数组作为函数参数的时候，这些声明方式是等价的：</p>
<ul>
<li><code>void foo(char str[20])</code></li>
<li><code>void foo(char str[])</code></li>
<li><code>void foo(char *str)</code></li>
</ul>
<p>但是对于二维数组或字符串数组，声明方式就必须准确了，因为它们的内存布局不同：</p>
<ul>
<li><code>void foo(char **str)</code>：处理字符串指针数组</li>
<li><code>void foo(char (*str)[20])</code>：处理二维字符数组</li>
</ul>
<p>所以其实我觉得<code>char *s[20]</code>才是更常用的写法，因为我们经常需要存储一组字符串。而<code>char (*s)[20]</code>这种指向数组的指针，主要是在处理二维数组的时候才会用到。</p>
<hr>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>src<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
 <span class="token keyword keyword-char">char</span> buffer<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> buffer<span class="token punctuation">;</span>
 <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>src<span class="token operator">++</span><span class="token punctuation">)</span>
 <span class="token punctuation">;</span>
 <span class="token keyword keyword-return">return</span> buffer<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre><pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>src<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
 <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>dst<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>src<span class="token operator">++</span><span class="token punctuation">)</span>
 <span class="token punctuation">;</span>
 <span class="token keyword keyword-return">return</span> dst<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre><p>让我来详细分析这两段代码的问题。</p>
<p>第一段代码存在严重问题：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>src<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> buffer<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> buffer<span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>src<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> buffer<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>这段代码有以下几个致命缺陷：</p>
<ol>
<li>返回了局部变量<code>buffer</code>的地址，这个数组在函数结束后就会被销毁，导致返回的是一个悬空指针</li>
<li>函数原型设计不合理，只有源字符串参数，没有目标字符串参数</li>
<li>使用了未定义的<code>MAX</code>常量，如果<code>MAX</code>小于源字符串长度会造成缓冲区溢出</li>
</ol>
<p>第二段代码是经典的<code>strcpy</code>实现：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>src<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>dst<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>src<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> dst<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>这段代码写法比较标准，但仍有一些小问题：</p>
<ol>
<li>返回值是拷贝完成后的<code>dst</code>指针位置（指向字符串结尾的空字符），一般来说应该返回目标字符串的起始位置</li>
<li>没有进行参数有效性检查，如果传入<code>NULL</code>指针会导致程序崩溃</li>
<li>如果源字符串和目标字符串内存区域有重叠，可能会导致数据覆盖</li>
</ol>
<p>一个更严谨的实现应该是：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>src<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>ret <span class="token operator">=</span> dst<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dst <span class="token operator">||</span> <span class="token operator">!</span>src<span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>dst<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>src<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>
        <span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>这个改进版本：</p>
<ol>
<li>保存并返回目标字符串的起始位置</li>
<li>增加了空指针检查</li>
<li>显式判断字符串结束符，使代码更易读</li>
<li>但仍然没有解决内存重叠问题，如果需要处理这种情况，应该使用<code>memmove</code>而不是<code>strcpy</code></li>
</ol>
<hr>
<blockquote>
<p>七、设有如下C语言程序：（5分）</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"happy"</span><span class="token punctuation">,</span> <span class="token string">"2019!"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
   p <span class="token operator">=</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token function">foo</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s %s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>该程序编译正确，但运行时输出乱码，并没有输出期望的"happy 2019!"。试分析原因。</p>
</blockquote>
<p>啊，这是一个很好的指针传递的例子。问题出在对数组指针的赋值上。让我分析一下：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// 等价于 void foo(char **p)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"happy"</span><span class="token punctuation">,</span> <span class="token string">"2019!"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// s在静态区</span>
    p <span class="token operator">=</span> s<span class="token punctuation">;</span>  <span class="token comment">//  这里只是改变了p这个局部变量，而不是main中的数组</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// p未初始化</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 传入p的地址，但foo函数并没有修改p的内容</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s %s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// p[0]和p[1]仍然是未初始化的</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>这里的问题是：</p>
<ol>
<li>虽然<code>p</code>是指针数组，但传入函数时，<code>p</code>本身在函数内是一个局部变量</li>
<li><code>p = s</code>这个赋值只改变了函数内<code>p</code>这个局部变量的值</li>
<li>并没有改变<code>main</code>函数中原数组的内容</li>
<li>所以<code>main</code>中的<code>p</code>数组依然是未初始化的</li>
</ol>
<p>要修复这个问题，有几种方法：</p>
<p>方法1：使用指针的指针</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span>  <span class="token comment">// 再加一层指针</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"happy"</span><span class="token punctuation">,</span> <span class="token string">"2019!"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token punctuation">;</span>  <span class="token comment">// 修改p指向的地址</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">;</span>      <span class="token comment">// 声明成指针的指针</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 传递p的地址</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s %s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>或</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>pp<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// pp是指向数组的指针</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"happy"</span><span class="token punctuation">,</span> <span class="token string">"2019!"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>pp<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 修改数组的每个元素</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>pp<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 传入p的地址</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s %s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 现在会正确输出：happy 2019!</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>方法2：复制数组元素</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"happy"</span><span class="token punctuation">,</span> <span class="token string">"2019!"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 逐个复制元素</span>
    p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s %s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>方法3：返回数组</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"happy"</span><span class="token punctuation">,</span> <span class="token string">"2019!"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s %s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>内存示意图：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>原始程序的内存布局：
              +——————————————+
              | "happy\0"    |
只读段         | "2019!\0"    |
              +——————————————+
              | s[0]→"happy" |  &lt;— static数组s在数据段
数据段         | s[1]→"2019!" |
              +——————————————+
              | p = &amp;s[0]    |  &lt;— foo函数的参数p指向了s
栈（foo函数）   |             |    但这个修改是局部的
              +——————————————+
              | p[0]→???    |  &lt;— main函数的数组p
栈（main函数）  | p[1]→???    |    完全没有被修改
              +——————————————+

修复后的内存布局（方法2）：
              +——————————————+
              | "happy\0"    |
只读段         | "2019!\0"    |
              +——————————————+
              | s[0]→"happy" |  &lt;— static数组s在数据段
数据段         | s[1]→"2019!" |
              +——————————————+
              | p[0]=s[0]    |  &lt;— foo函数直接修改了
栈（foo函数）   | p[1]=s[1]    |    传入数组的内容
              +——————————————+
              | p[0]→"happy" |  &lt;— main函数的数组p
栈（main函数）  | p[1]→"2019!" |    被正确赋值
              +——————————————+
</code></pre><p>这个例子很好地说明了：</p>
<ol>
<li>函数参数传递时的值传递特性</li>
<li>修改参数本身和修改参数指向的内容的区别</li>
<li>要修改调用者的数组，要么传入数组地址，要么直接修改数组元素</li>
</ol>
<p><strong>补充知识1</strong></p>
<p>不能直接这样写。我来解释下这三种写法的本质区别：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 第一种：二维字符数组</span>
<span class="token keyword keyword-char">char</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Stay"</span><span class="token punctuation">,</span> <span class="token string">"Safe"</span><span class="token punctuation">,</span> <span class="token string">"From"</span><span class="token punctuation">,</span> <span class="token string">"Covid"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">/*
相当于：
char a[4][8] = {
    {'S','t','a','y','\0','\0','\0','\0'},
    {'S','a','f','e','\0','\0','\0','\0'},
    {'F','r','o','m','\0','\0','\0','\0'},
    {'C','o','v','i','d','\0','\0','\0'}
};
*/</span>

<span class="token comment">// 第二种：字符指针数组</span>
<span class="token keyword keyword-char">char</span> <span class="token operator">*</span>a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Stay"</span><span class="token punctuation">,</span> <span class="token string">"Safe"</span><span class="token punctuation">,</span> <span class="token string">"From"</span><span class="token punctuation">,</span> <span class="token string">"Covid"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">/*
相当于：
char *a[4];
a[0] = &amp;"Stay"[0];    // 指向只读段中的字符串
a[1] = &amp;"Safe"[0];
a[2] = &amp;"From"[0];
a[3] = &amp;"Covid"[0];
*/</span>

<span class="token comment">// 第三种：错误写法</span>
<span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Stay"</span><span class="token punctuation">,</span> <span class="token string">"Safe"</span><span class="token punctuation">,</span> <span class="token string">"From"</span><span class="token punctuation">,</span> <span class="token string">"Covid"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// ❌ 编译错误</span>
</code></pre><p>为什么第三种写法不行：</p>
<ol>
<li><code>char **a</code>是一个指针变量，只能存储一个地址</li>
<li>而<code>{"Stay", "Safe", "From", "Covid"}</code>是一个指针数组的初始化列表</li>
<li>不能把一个数组直接赋值给一个指针变量</li>
</ol>
<p>如果要用<code>char **</code>，正确的写法是：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 方法1：先定义静态数组</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>strings<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Stay"</span><span class="token punctuation">,</span> <span class="token string">"Safe"</span><span class="token punctuation">,</span> <span class="token string">"From"</span><span class="token punctuation">,</span> <span class="token string">"Covid"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>a <span class="token operator">=</span> strings<span class="token punctuation">;</span>

<span class="token comment">// 方法2：动态分配内存</span>
<span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>a <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Stay"</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Safe"</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"From"</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Covid"</span><span class="token punctuation">;</span>
</code></pre><p>内存布局对比：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>第一种（二维数组）：
[S][t][a][y][\0][\0][\0][\0]   ← a[0]是8字节的数组
[S][a][f][e][\0][\0][\0][\0]   ← a[1]是8字节的数组
[F][r][o][m][\0][\0][\0][\0]   ← a[2]是8字节的数组
[C][o][v][i][d][\0][\0][\0]    ← a[3]是8字节的数组

第二种（指针数组）：
[ptr→"Stay"]    ← a[0]是一个指针
[ptr→"Safe"]    ← a[1]是一个指针
[ptr→"From"]    ← a[2]是一个指针
[ptr→"Covid"]   ← a[3]是一个指针

第三种（双指针，如果可以的话）：
[ptr]           ← a只是一个指针，不能存储多个字符串地址
</code></pre><p>记住：</p>
<ol>
<li><code>char a[][8]</code>是一块连续的内存，可以存储多个固定长度的字符串</li>
<li><code>char *a[]</code>是一个指针数组，每个元素可以指向不同的字符串</li>
<li><code>char **a</code>只是一个指针变量，需要额外的内存分配才能管理多个字符串</li>
</ol>
<p><strong>补充知识2</strong></p>
<p>这是个好问题！让我解释一下为什么会这样：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>str0 <span class="token operator">=</span> <span class="token string">"Stay"</span><span class="token punctuation">;</span>
</code></pre><p>这行代码中：</p>
<ol>
<li><code>"Stay"</code>在内存中是这样存储的：<code>['S']['t']['a']['y']['\0']</code></li>
<li><code>str0</code>指向的是第一个字符<code>'S'</code>的地址</li>
</ol>
<p>所以：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> str0<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// ✅ 正确：从str0指向的地址开始，一直打印到'\0'</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>str0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ❌ 错误：把字符'S'当作地址来解释</span>
</code></pre><p>第一种写法中：</p>
<ul>
<li><code>%s</code>期望接收一个字符串的起始地址</li>
<li><code>str0</code>本身就是地址（比如<code>0x12345678</code>）</li>
<li><code>printf</code>从这个地址开始读取字符，直到遇到<code>'\0'</code></li>
<li>所以会打印出完整的<code>"Stay"</code></li>
</ul>
<p>第二种写法中：</p>
<ul>
<li><code>*str0</code>解引用得到字符<code>'S'</code>（比如ASCII码<code>83</code>）</li>
<li><code>%s</code>会把这个数字<code>83</code>当作内存地址</li>
<li>试图从地址<code>83</code>开始读取字符</li>
<li>这通常会导致程序崩溃（段错误）</li>
</ul>
<p>让我用代码演示一下：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>str0 <span class="token operator">=</span> <span class="token string">"Stay"</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"str0的值（地址）：%p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span>str0<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 比如：0x12345678</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*str0的值（字符）：%c (%d)\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>str0<span class="token punctuation">,</span> <span class="token operator">*</span>str0<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// S (83)</span>
</code></pre><p>更直观的内存示意图：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>内存地址    内容
0x12345678  'S'  ← str0指向这里
0x12345679  't'
0x1234567A  'a'
0x1234567B  'y'
0x1234567C  '\0'

printf("%s", str0)   → 从0x12345678开始读取，得到"Stay"
printf("%s", *str0)  → 把83当作地址（0x53），访问无效内存
</code></pre><p>如果你想用解引用来打印字符串，应该这样写：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 打印单个字符</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>str0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 打印'S'</span>

<span class="token comment">// 手动遍历字符串</span>
<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> str0<span class="token punctuation">;</span>
<span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>这就是为什么：</p>
<ol>
<li><code>%s</code>格式符需要的是字符串的地址</li>
<li>字符指针直接传给<code>%s</code>是对的（传递的是地址）</li>
<li>解引用字符指针得到的是单个字符，不能用<code>%s</code>打印</li>
</ol>
<hr>
<blockquote>
<p>设有如下GCC程序：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword keyword-int">int</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token keyword keyword-return">return</span> n<span class="token operator">--</span> <span class="token operator">+</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n=%d, sum=%d\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>该程序在X86下用GCC正确编译，但运行时输出如下：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>n=0, sum=15
</code></pre><p>不是所期望的<code>n=5, sum=15</code>。试分析原因</p>
</blockquote>
<p><strong>考试回答</strong></p>
<ol>
<li>在x86体系下，C语言函数调用采用栈传参，参数从右向左压栈</li>
<li>所以<code>printf("n=%d, sum=%d\n", n, sum())</code>会先计算并压入<code>sum()</code>的值（15）</li>
<li>由于<code>sum()</code>函数递归过程会修改全局变量<code>n</code>，使其最终变为0</li>
<li>然后再取<code>n</code>的值压栈，此时获取到的就是0</li>
<li>所以最终输出<code>n=0, sum=15</code></li>
</ol>
<p>这样回答就比较符合考试需求：</p>
<ul>
<li>说明了函数调用的基本机制（参数压栈顺序）</li>
<li>解释了代码的实际执行过程</li>
<li>指出了导致结果的关键点（全局变量被修改）</li>
<li>给出了最终结果</li>
</ul>
<p>避免讨论：</p>
<ul>
<li>不同编译器的具体实现差异</li>
<li>C语言标准中的未定义行为</li>
<li>求值顺序的复杂性</li>
<li>代码改进建议</li>
</ul>
<p><strong>背后的真实</strong></p>
<p>确实，这种情况下的行为是非常混乱的，因为涉及到了多个未定义行为（Undefined Behavior）。</p>
<p>在C语言中，以下行为都是未定义的：</p>
<ol>
<li>在一个序列点（Sequence Point）之间多次修改同一个变量</li>
<li>在一个表达式中既读又写同一个变量</li>
<li>函数参数的求值顺序</li>
</ol>
<p>让我们看看你给的例子：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d,%d,%d,%d,%d,%d,%d\n"</span><span class="token punctuation">,</span> z<span class="token operator">--</span><span class="token punctuation">,</span> z<span class="token operator">++</span><span class="token punctuation">,</span> z <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> z<span class="token operator">++</span><span class="token punctuation">,</span> z <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> z <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">--</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>这里面有多个问题：</p>
<ol>
<li>在一次函数调用中对<code>z</code>进行了多次修改</li>
<li>有些表达式既读又写<code>z</code>（比如<code>z++</code>、<code>--z</code>）</li>
<li>每个参数的求值顺序是未定义的</li>
</ol>
<p>为什么局部变量和全局变量会有不同的行为：</p>
<ul>
<li>局部变量通常存在栈上，访问方式是直接的</li>
<li>全局变量存在数据段中，访问可能涉及额外的寻址</li>
<li>不同的编译器可能会对它们采用不同的优化策略</li>
</ul>
<p>所以正确的做法是：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> z <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> a <span class="token operator">=</span> z<span class="token operator">--</span><span class="token punctuation">;</span>     <span class="token comment">// 每次修改都要用一个序列点隔开</span>
<span class="token keyword keyword-int">int</span> b <span class="token operator">=</span> z<span class="token operator">++</span><span class="token punctuation">;</span>
z <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> c <span class="token operator">=</span> z<span class="token operator">++</span><span class="token punctuation">;</span>
z <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> d <span class="token operator">=</span> z <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> e <span class="token operator">=</span> <span class="token operator">--</span>z<span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d,%d,%d,%d,%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>或者干脆：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> z <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 每次printf都只用一次z</span>
z<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 以此类推</span>
</code></pre><p>总的来说：</p>
<ol>
<li>这种代码确实是未定义行为</li>
<li>不同编译器会有不同的处理方式</li>
<li>即使同一个编译器，不同优化级别可能也会有不同结果</li>
<li>应该避免写这种代码，而是使用清晰可预测的方式</li>
</ol>
<p>这也提醒我们：理解C语言的未定义行为很重要，不要依赖这些行为编程，因为它们的结果是不可预测的。</p>
<p>顺便一提：那个你说的"原则"也只是一种经验总结，并不是语言标准规定的行为。在不同的编译器、不同的环境下可能会有完全不同的结果。</p>
<hr>
<p>对于前面的例子：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> z <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d,%d,%d,%d,%d,%d,%d\n"</span><span class="token punctuation">,</span> z<span class="token operator">--</span><span class="token punctuation">,</span> z<span class="token operator">++</span><span class="token punctuation">,</span> z <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> z<span class="token operator">++</span><span class="token punctuation">,</span> z <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> z <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">--</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>用GCC的<code>-S</code>选项看看生成的汇编代码：</p>
<pre data-role="codeBlock" data-info="x86asm" class="language-x86asm x86asm"><code>	.file	"test.c"
	.text
	.def	__main;	.scl	2;	.type	32;	.endef
	.section .rdata,"dr"
.LC0:
	.ascii "%d,%d,%d,%d,%d,%d,%d\12\0"
	.text
	.globl	main
	.def	main;	.scl	2;	.type	32;	.endef
	.seh_proc	main
main:
	pushq	%rbp
	.seh_pushreg	%rbp
	movq	%rsp, %rbp
	.seh_setframe	%rbp, 0
	subq	$80, %rsp
	.seh_stackalloc	80
	.seh_endprologue
	call	__main
	movl	$4, -4(%rbp)
	subl	$1, -4(%rbp)
	movl	-4(%rbp), %eax
	leal	1(%rax), %r9d
	movl	$1, -4(%rbp)
	movl	-4(%rbp), %edx
	leal	1(%rdx), %eax
	movl	%eax, -4(%rbp)
	movl	$100, -4(%rbp)
	movl	-4(%rbp), %ecx
	leal	1(%rcx), %eax
	movl	%eax, -4(%rbp)
	movl	-4(%rbp), %eax
	leal	-1(%rax), %r8d
	movl	%r8d, -4(%rbp)
	movl	-4(%rbp), %r10d
	movl	-4(%rbp), %r8d
	movl	%r8d, 56(%rsp)
	movl	%r9d, 48(%rsp)
	movl	-4(%rbp), %r8d
	movl	%r8d, 40(%rsp)
	movl	%edx, 32(%rsp)
	movl	%r10d, %r9d
	movl	%ecx, %r8d
	movl	%eax, %edx
	leaq	.LC0(%rip), %rcx
	call	printf
	movl	$0, %eax
	addq	$80, %rsp
	popq	%rbp
	ret
	.seh_endproc
	.ident	"GCC: (x86_64-win32-seh-rev0, Built by MinGW-W64 project) 8.1.0"
	.def	printf;	.scl	2;	.type	32;	.endef
</code></pre><p>让我尝试按照汇编代码一步步分析这个过程。为了方便理解，我先把关键的部分简化并加上注释：</p>
<pre data-role="codeBlock" data-info="x86asm" class="language-x86asm x86asm"><code>movl $4, -4(%rbp)      ; z = 4
subl $1, -4(%rbp)      ; z--，现在z = 3
movl -4(%rbp), %eax    
leal 1(%rax), %r9d     ; r9d = z + 1 = 4

movl $1, -4(%rbp)      ; z = 1
movl -4(%rbp), %edx    ; edx = 1
leal 1(%rdx), %eax     ; eax = z + 1 = 2
movl %eax, -4(%rbp)    ; z = 2

movl $100, -4(%rbp)    ; z = 100
movl -4(%rbp), %ecx    ; ecx = 100
leal 1(%rcx), %eax     ; eax = z + 1 = 101
movl %eax, -4(%rbp)    ; z = 101

movl -4(%rbp), %eax    ; eax = 101
leal -1(%rax), %r8d    ; r8d = z - 1 = 100
movl %r8d, -4(%rbp)    ; z = 100
movl -4(%rbp), %r10d   ; r10d = 100
movl -4(%rbp), %r8d    ; r8d = 100
</code></pre><p>然后是参数准备和函数调用：</p>
<pre data-role="codeBlock" data-info="x86asm" class="language-x86asm x86asm"><code>movl %r8d, 56(%rsp)    ; 第7个参数 = 100（--z的结果）
movl %r9d, 48(%rsp)    ; 第6个参数 = 4（z + 1的结果）
movl -4(%rbp), %r8d    
movl %r8d, 40(%rsp)    ; 第5个参数 = 100（z = 1的结果）
movl %edx, 32(%rsp)    ; 第4个参数 = 1（z++的结果）
movl %r10d, %r9d       ; 第3个参数 = 100（z = 100的结果）
movl %ecx, %r8d        ; 第2个参数 = 100（z++的结果）
movl %eax, %edx        ; 第1个参数 = 101（z--的结果）
</code></pre><p>所以最终<code>printf</code>接收到的7个参数从左到右是：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>101, 100, 100, 1, 100, 4, 100
</code></pre><p>这个结果确实很奇怪，但是我们可以看到：</p>
<ol>
<li>编译器重排了表达式的执行顺序</li>
<li>某些值被保存在寄存器中而不是直接使用内存中的值</li>
<li>有些修改操作的结果被"忽略"了</li>
<li>编译器可能做了一些优化，导致某些操作的顺序和结果与直觉不符</li>
</ol>
<p>这也再次说明了为什么我们不应该依赖这种未定义行为：编译器可能会以任何方式重排和优化这些操作，导致最终结果难以预测。即使我们能从汇编代码中看出执行过程，这个行为在不同的编译器或不同的优化级别下可能都会不一样。</p>
<hr>
<blockquote>
<p>设有如下GCC程序：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> dest<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> src<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword keyword-int">int</span> i<span class="token punctuation">;</span>
   <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> src<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
       dest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> src<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
       dest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
   <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword keyword-char">char</span> s<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"happy 2016"</span><span class="token punctuation">;</span>
   <span class="token keyword keyword-char">char</span> t<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token function">foo</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s, %d\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>该程序在X86下用GCC能正确编译，但运行时输出如下乱码：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>happ⍰⍰⍰⍰, 20
</code></pre><p>试分析原因</p>
</blockquote>
<p>啊，这个问题出在对<code>sizeof</code>的误用上。在函数参数中，数组会退化为指针，所以这里的行为和预期不一样。让我分析一下：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> dest<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> src<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  
<span class="token comment">// 实际上等价于：void foo(char *dest, char *src)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> src<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token comment">//     ↑这里是重点，sizeof(src)是指针的大小，而不是数组大小</span>
        dest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> src<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        dest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>问题在于：</p>
<ol>
<li>在函数参数中，<code>char src[20]</code>会被编译器转换为<code>char *src</code></li>
<li>所以<code>sizeof(src)</code>返回的是指针的大小（在32位系统上是4，64位系统是8）</li>
<li>而不是我们期望的数组大小20</li>
<li>结果就是只复制了前4（或8）个字符</li>
</ol>
<p>修复这个问题有几种方法：</p>
<p>方法1：传入数组大小</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> dest<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> src<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span> src<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        dest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> src<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        dest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> s<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"happy 2016"</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> t<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 传入实际的数组大小</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s, %d\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>方法2：使用字符串函数</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> dest<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> src<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>dest<span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 复制字符串</span>
    <span class="token comment">// 或者更安全的方式：</span>
    <span class="token comment">// strncpy(dest, src, 19);</span>
    <span class="token comment">// dest[19] = '\0';</span>
<span class="token punctuation">}</span>
</code></pre><p>方法3：修改循环条件</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> dest<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> src<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>src<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 只复制到字符串结束</span>
        dest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> src<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    dest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>  <span class="token comment">// 确保添加结束符</span>
<span class="token punctuation">}</span>
</code></pre><p>让我们看看错误程序在内存中的情况：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>以32位系统为例（sizeof(char*) = 4）：

原始字符串：
s[20] = "happy 2016\0........"  // .表示未使用的空间
索引：    0123456789
内容：    happy 2016\0

foo函数执行过程：
1. sizeof(src) = 4（指针大小）
2. 只复制前4个字符：
   t[20] = "happ\0............"

最终输出：
"happ" （后面可能跟着垃圾值）
</code></pre><p>正确的程序应该是：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>正确复制整个字符串：
s[20] = "happy 2016\0........"
t[20] = "happy 2016\0........"

输出：
"happy 2016"
</code></pre><p>这个例子说明：</p>
<ol>
<li>在C语言中，数组作为函数参数时会退化为指针</li>
<li>在函数内部无法通过<code>sizeof</code>获取传入数组的实际大小</li>
<li>处理字符串时要特别注意结束符<code>\0</code></li>
<li>最好使用标准库函数如<code>strcpy</code>、<code>strncpy</code>来处理字符串</li>
</ol>
<p>这也是为什么C标准库的字符串函数通常都需要传入缓冲区大小，比如<code>strncpy</code>、<code>strncat</code>等。因为函数内部无法知道传入数组的实际大小，必须由调用者显式提供这个信息。</p>
<hr>
<blockquote>
<p>设有如下C语言程序：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0x35313032</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0x34313032</span><span class="token punctuation">;</span>
   <span class="token function">foo</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>已知字符<code>'0'</code>（自然数零）的ASCII码为<code>0x30</code>。该程序在X86下用gcc能正确编译，且运行正常。试分析运行输出的结果。</p>
</blockquote>
<p>这是个很有趣的例子，涉及到字节序（endianness）和ASCII编码。让我来分析一下。</p>
<p>首先，我注意到代码有点问题：</p>
<ol>
<li><code>foo</code>函数声明和定义不匹配（参数个数不同）</li>
<li>但提示说能正确编译，说明实际使用的是单参数版本</li>
</ol>
<p>让我们来看看这些十六进制数字：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0x35313032</span><span class="token punctuation">;</span>  <span class="token comment">// 按字节分解：0x35 0x31 0x30 0x32</span>
<span class="token keyword keyword-int">int</span> j <span class="token operator">=</span> <span class="token number">0x34313032</span><span class="token punctuation">;</span>  <span class="token comment">// 这个j其实没用到</span>
</code></pre><p>在X86（小端序）系统中，<code>int i</code>在内存中的存储方式是：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>高地址 → 0x35 (ASCII：'5')
         0x31 (ASCII：'1')
         0x30 (ASCII：'0')
低地址 → 0x32 (ASCII：'2')
</code></pre><p>当执行：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>这里把<code>i</code>的地址强制转换成<code>char*</code>，然后用<code>printf</code>的<code>%s</code>格式输出，<code>printf</code>会把这个地址当作字符串的起始位置，从低地址开始读取，直到遇到<code>\0</code>。</p>
<p>所以实际读取顺序是：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>0x32 → ASCII '2'
0x30 → ASCII '0'
0x31 → ASCII '1'
0x35 → ASCII '5'
</code></pre><p>因此输出结果应该是：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>2015
</code></pre><p>这个程序能工作是因为：</p>
<ol>
<li>X86是小端序，数字的存储顺序正好形成了我们想要的字符串</li>
<li>这些十六进制数正好对应了ASCII数字字符的编码</li>
<li>虽然这个做法很巧妙，但不推荐在实际编程中使用，因为：
<ul>
<li>依赖于机器的字节序</li>
<li>可能会访问越界（如果后面没有<code>\0</code>）</li>
<li>代码可读性差</li>
<li>可能违反类型别名规则</li>
</ul>
</li>
</ol>
<p>更规范的写法应该是：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"2015"</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>顺便说一下，如果在大端序机器上运行这段代码，输出会是：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>5102
</code></pre><p>因为内存布局会变成：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>高地址 → 0x32 (ASCII：'2')
         0x30 (ASCII：'0')
         0x31 (ASCII：'1')
低地址 → 0x35 (ASCII：'5')
</code></pre><p>这就是为什么这种技巧在实际编程中不可靠，因为它依赖于特定的硬件架构特性。</p>
<p><strong>参考答案</strong></p>
<p>原始代码是：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0x35313032</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0x34313032</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 实际调用时传了3个参数</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span>       <span class="token comment">// 但函数定义只接收1个参数</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>关键点在于：</p>
<ol>
<li>调用时传了3个参数（<code>i</code>, <code>j</code>, <code>0</code>）</li>
<li>在x86下，GCC调用函数时会<strong>从右向左</strong>把参数压栈</li>
<li>函数虽然只声明接收一个参数，但栈上实际有3个参数的空间</li>
</ol>
<p>所以参数入栈顺序是：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>第三个参数：0
第二个参数：j (0x34313032)
第一个参数：i (0x35313032)
返回地址
</code></pre><p>当在<code>foo</code>函数中执行：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>由于是小端序，从低地址开始读取，内存布局是：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>高地址 → ... ...
         0x34 ('4')
         0x31 ('1')
         0x30 ('0')
         0x32 ('2')  → j的字节
         0x35 ('5')
         0x31 ('1')
         0x30 ('0')
低地址 → 0x32 ('2')  → i的字节
</code></pre><p>所以<code>printf</code>会从低地址开始读取字符，直到遇到<code>\0</code>，实际输出：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>20152014
</code></pre><p><strong>背后的真实</strong></p>
<p>对，这道题的参考答案确实有点牵强。我也认为从C语言的规范来说，这种参数不匹配的情况属于未定义行为（undefined behavior）。</p>
<p>按照C标准：</p>
<ol>
<li>函数声明和定义不匹配是未定义行为</li>
<li>调用时传入的参数个数与函数定义不匹配也是未定义行为</li>
</ol>
<p>所以这段代码的实际运行结果可能会因编译器版本、优化级别、操作系统版本等因素而不同：</p>
<ul>
<li>有的编译器可能只使用第一个参数（输出"2015"）</li>
<li>有的可能会读取到后续参数（输出"20152014"）</li>
<li>甚至可能出现其他完全不同的结果</li>
</ul>
<p>参考答案虽然解释了在特定环境下可能出现"20152014"的原理，但把这个作为标准答案是不合适的，因为：</p>
<ol>
<li>这种行为不具有可移植性</li>
<li>不同环境下结果不可预测</li>
<li>本身就是错误的代码写法</li>
</ol>
<p>更好的出题方式应该是：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0x35313032</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>这样至少能确保函数调用是合法的，我们只需要讨论小端序和ASCII编码的影响就够了。</p>

      </div>
      
      
    
    
    
    
    
    
  
    </body></html>