<!DOCTYPE html><html><head>
      <title>CP_4</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
      
      
      
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<p>从最小化DFA的状态转换图到词法分析程序的转换，本质上是将自动机的状态转换过程转化为程序的控制流。让我详细讲解这个转换过程。</p>
<p>基本思路：</p>
<ol>
<li>
<p>程序的基本框架</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>while(还有输入) {
  获取下一个字符
  根据当前状态和输入字符进行状态转换
  if(到达终态) {
    执行相应动作
    重置状态
  }
}
</code></pre></li>
<li>
<p>状态的表示方式</p>
<ol>
<li>
<p>switch-case方式</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-switch">switch</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-case">case</span> <span class="token number">0</span><span class="token operator">:</span>
    <span class="token comment">// 状态0的转换逻辑</span>
    <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-case">case</span> <span class="token number">1</span><span class="token operator">:</span>
    <span class="token comment">// 状态1的转换逻辑</span>
    <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></li>
<li>
<p>状态转移表方式</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> trans_table<span class="token punctuation">[</span>STATE_NUM<span class="token punctuation">]</span><span class="token punctuation">[</span>CHAR_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>
state <span class="token operator">=</span> trans_table<span class="token punctuation">[</span>state<span class="token punctuation">]</span><span class="token punctuation">[</span>char_class<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></li>
</ol>
</li>
</ol>
<p>让我用一个具体例子来说明。假设有一个识别C语言标识符的最小化DFA：</p>
<p class="dot"><!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<!-- Generated by graphviz version 9.0.0 (20230911.1827)
 -->
<!-- Title: MinDFA Pages: 1 -->
<svg width="372pt" height="179pt" viewBox="0.00 0.00 371.62 179.22" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 175.22)">
<title>MinDFA</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-175.22 367.62,-175.22 367.62,4 -4,4"></polygon>
<!-- start -->
<g id="node1" class="node">
<title>start</title>
</g>
<!-- q0 -->
<g id="node2" class="node">
<title>q0</title>
<ellipse fill="none" stroke="black" cx="109" cy="-22.62" rx="18" ry="18"></ellipse>
<text text-anchor="middle" x="109" y="-18.42" font-family="Times,serif" font-size="14.00">0</text>
</g>
<!-- start&#45;&gt;q0 -->
<g id="edge1" class="edge">
<title>start-&gt;q0</title>
<path fill="none" stroke="black" d="M53.75,-22.62C61.85,-22.62 70.85,-22.62 79.16,-22.62"></path>
<polygon fill="black" stroke="black" points="79.12,-26.12 89.12,-22.62 79.12,-19.12 79.12,-26.12"></polygon>
</g>
<!-- q1 -->
<g id="node3" class="node">
<title>q1</title>
<ellipse fill="none" stroke="black" cx="213.76" cy="-79.62" rx="18" ry="18"></ellipse>
<ellipse fill="none" stroke="black" cx="213.76" cy="-79.62" rx="22" ry="22"></ellipse>
<text text-anchor="middle" x="213.76" y="-75.42" font-family="Times,serif" font-size="14.00">1</text>
</g>
<!-- q0&#45;&gt;q1 -->
<g id="edge2" class="edge">
<title>q0-&gt;q1</title>
<path fill="none" stroke="black" d="M125.16,-31.03C140.61,-39.6 164.95,-53.1 184.06,-63.7"></path>
<polygon fill="black" stroke="black" points="182.28,-66.72 192.72,-68.51 185.68,-60.6 182.28,-66.72"></polygon>
<text text-anchor="middle" x="159.38" y="-61.82" font-family="Times,serif" font-size="14.00">letter</text>
</g>
<!-- q2 -->
<g id="node4" class="node">
<title>q2</title>
<ellipse fill="none" stroke="black" cx="318.52" cy="-22.62" rx="18" ry="18"></ellipse>
<text text-anchor="middle" x="318.52" y="-18.42" font-family="Times,serif" font-size="14.00">2</text>
</g>
<!-- q0&#45;&gt;q2 -->
<g id="edge3" class="edge">
<title>q0-&gt;q2</title>
<path fill="none" stroke="black" d="M127.34,-22.62C163.04,-22.62 245.1,-22.62 288.84,-22.62"></path>
<polygon fill="black" stroke="black" points="288.58,-26.12 298.58,-22.62 288.58,-19.12 288.58,-26.12"></polygon>
<text text-anchor="middle" x="213.76" y="-26.82" font-family="Times,serif" font-size="14.00">digit</text>
</g>
<!-- q0&#45;&gt;q2 -->
<g id="edge4" class="edge">
<title>q0-&gt;q2</title>
<path fill="none" stroke="black" d="M126.37,-17.17C142.71,-12.04 168.65,-4.72 191.76,-1.82 211.16,0.61 216.35,0.61 235.76,-1.82 254.35,-4.15 274.79,-9.35 290.57,-13.96"></path>
<polygon fill="black" stroke="black" points="289.12,-17.18 299.71,-16.73 291.15,-10.48 289.12,-17.18"></polygon>
<text text-anchor="middle" x="213.76" y="-5.82" font-family="Times,serif" font-size="14.00">other</text>
</g>
<!-- q1&#45;&gt;q1 -->
<g id="edge5" class="edge">
<title>q1-&gt;q1</title>
<path fill="none" stroke="black" d="M208.74,-101.43C208.26,-111.18 209.94,-119.62 213.76,-119.62 215.91,-119.62 217.38,-116.95 218.17,-112.88"></path>
<polygon fill="black" stroke="black" points="221.66,-113.11 218.7,-102.94 214.67,-112.74 221.66,-113.11"></polygon>
<text text-anchor="middle" x="213.76" y="-123.82" font-family="Times,serif" font-size="14.00">letter</text>
</g>
<!-- q1&#45;&gt;q1 -->
<g id="edge6" class="edge">
<title>q1-&gt;q1</title>
<path fill="none" stroke="black" d="M205.25,-100.44C201.36,-118.51 204.2,-137.62 213.76,-137.62 221.3,-137.62 224.66,-125.72 223.83,-111.82"></path>
<polygon fill="black" stroke="black" points="227.3,-111.37 222.48,-101.93 220.37,-112.32 227.3,-111.37"></polygon>
<text text-anchor="middle" x="213.76" y="-141.82" font-family="Times,serif" font-size="14.00">digit</text>
</g>
<!-- q1&#45;&gt;q2 -->
<g id="edge7" class="edge">
<title>q1-&gt;q2</title>
<path fill="none" stroke="black" d="M233.61,-69.17C250.08,-60.03 274.12,-46.7 292.25,-36.64"></path>
<polygon fill="black" stroke="black" points="293.78,-39.8 300.82,-31.89 290.38,-33.68 293.78,-39.8"></polygon>
<text text-anchor="middle" x="268.14" y="-61.82" font-family="Times,serif" font-size="14.00">other</text>
</g>
<!-- q2&#45;&gt;q2 -->
<g id="edge8" class="edge">
<title>q2-&gt;q2</title>
<path fill="none" stroke="black" d="M309.82,-38.54C307.56,-48.77 310.46,-58.62 318.52,-58.62 323.44,-58.62 326.44,-54.96 327.52,-49.79"></path>
<polygon fill="black" stroke="black" points="331.02,-49.96 327.26,-40.05 324.03,-50.14 331.02,-49.96"></polygon>
<text text-anchor="middle" x="318.52" y="-62.82" font-family="Times,serif" font-size="14.00">letter,digit,other</text>
</g>
</g>
</svg>
</p><p>转换成程序流程图：</p>
<p class="dot"><!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<!-- Generated by graphviz version 9.0.0 (20230911.1827)
 -->
<!-- Title: FlowChart Pages: 1 -->
<svg width="562pt" height="719pt" viewBox="0.00 0.00 562.40 719.20" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 715.2)">
<title>FlowChart</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-715.2 558.4,-715.2 558.4,4 -4,4"></polygon>
<!-- start -->
<g id="node1" class="node">
<title>start</title>
<ellipse fill="none" stroke="black" cx="484.4" cy="-693.2" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="484.4" y="-689" font-family="Times,serif" font-size="14.00">开始</text>
</g>
<!-- init -->
<g id="node2" class="node">
<title>init</title>
<polygon fill="none" stroke="black" points="516.17,-638.2 452.62,-638.2 452.62,-579.8 516.17,-579.8 516.17,-638.2"></polygon>
<text text-anchor="middle" x="484.4" y="-621.6" font-family="Times,serif" font-size="14.00">初始化</text>
<text text-anchor="middle" x="484.4" y="-604.8" font-family="Times,serif" font-size="14.00">state = 0</text>
<text text-anchor="middle" x="484.4" y="-588" font-family="Times,serif" font-size="14.00">pos = 0</text>
</g>
<!-- start&#45;&gt;init -->
<g id="edge1" class="edge">
<title>start-&gt;init</title>
<path fill="none" stroke="black" d="M484.4,-674.77C484.4,-667.43 484.4,-658.56 484.4,-649.77"></path>
<polygon fill="black" stroke="black" points="487.9,-649.92 484.4,-639.92 480.9,-649.92 487.9,-649.92"></polygon>
</g>
<!-- read -->
<g id="node3" class="node">
<title>read</title>
<polygon fill="none" stroke="black" points="378,-542.8 306.79,-542.8 306.79,-506.8 378,-506.8 378,-542.8"></polygon>
<text text-anchor="middle" x="342.4" y="-520.6" font-family="Times,serif" font-size="14.00">读取字符ch</text>
</g>
<!-- init&#45;&gt;read -->
<g id="edge2" class="edge">
<title>init-&gt;read</title>
<path fill="none" stroke="black" d="M452.18,-589.35C431.46,-577.35 404.38,-561.68 382.3,-548.9"></path>
<polygon fill="black" stroke="black" points="384.27,-545.99 373.86,-544.01 380.76,-552.05 384.27,-545.99"></polygon>
</g>
<!-- check_input -->
<g id="node4" class="node">
<title>check_input</title>
<polygon fill="none" stroke="black" points="342.4,-469.8 279.76,-451.8 342.4,-433.8 405.04,-451.8 342.4,-469.8"></polygon>
<text text-anchor="middle" x="342.4" y="-447.6" font-family="Times,serif" font-size="14.00">输入结束?</text>
</g>
<!-- read&#45;&gt;check_input -->
<g id="edge3" class="edge">
<title>read-&gt;check_input</title>
<path fill="none" stroke="black" d="M342.4,-506.61C342.4,-499.03 342.4,-489.9 342.4,-481.34"></path>
<polygon fill="black" stroke="black" points="345.9,-481.34 342.4,-471.34 338.9,-481.34 345.9,-481.34"></polygon>
</g>
<!-- state0 -->
<g id="node5" class="node">
<title>state0</title>
<polygon fill="none" stroke="black" points="290.4,-381 214.64,-363 290.4,-345 366.16,-363 290.4,-381"></polygon>
<text text-anchor="middle" x="290.4" y="-358.8" font-family="Times,serif" font-size="14.00">state == 0?</text>
</g>
<!-- check_input&#45;&gt;state0 -->
<g id="edge5" class="edge">
<title>check_input-&gt;state0</title>
<path fill="none" stroke="black" d="M333.58,-436.08C325.85,-423.19 314.47,-404.19 305.33,-388.93"></path>
<polygon fill="black" stroke="black" points="308.36,-387.17 300.21,-380.39 302.35,-390.76 308.36,-387.17"></polygon>
<text text-anchor="middle" x="326.65" y="-403.2" font-family="Times,serif" font-size="14.00">否</text>
</g>
<!-- end -->
<g id="node14" class="node">
<title>end</title>
<ellipse fill="none" stroke="black" cx="411.4" cy="-363" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="411.4" y="-358.8" font-family="Times,serif" font-size="14.00">结束</text>
</g>
<!-- check_input&#45;&gt;end -->
<g id="edge4" class="edge">
<title>check_input-&gt;end</title>
<path fill="none" stroke="black" d="M353.48,-436.85C363.93,-423.71 379.8,-403.75 392.28,-388.05"></path>
<polygon fill="black" stroke="black" points="394.75,-390.57 398.23,-380.56 389.27,-386.21 394.75,-390.57"></polygon>
<text text-anchor="middle" x="387.65" y="-403.2" font-family="Times,serif" font-size="14.00">是</text>
</g>
<!-- state1 -->
<g id="node6" class="node">
<title>state1</title>
<polygon fill="none" stroke="black" points="358.4,-292.2 282.64,-274.2 358.4,-256.2 434.16,-274.2 358.4,-292.2"></polygon>
<text text-anchor="middle" x="358.4" y="-270" font-family="Times,serif" font-size="14.00">state == 1?</text>
</g>
<!-- state0&#45;&gt;state1 -->
<g id="edge7" class="edge">
<title>state0-&gt;state1</title>
<path fill="none" stroke="black" d="M301.93,-347.28C312.35,-333.98 327.86,-314.18 339.99,-298.69"></path>
<polygon fill="black" stroke="black" points="342.69,-300.93 346.1,-290.9 337.18,-296.61 342.69,-300.93"></polygon>
<text text-anchor="middle" x="336.65" y="-314.4" font-family="Times,serif" font-size="14.00">否</text>
</g>
<!-- check0_letter -->
<g id="node7" class="node">
<title>check0_letter</title>
<polygon fill="none" stroke="black" points="212.4,-292.2 160,-274.2 212.4,-256.2 264.8,-274.2 212.4,-292.2"></polygon>
<text text-anchor="middle" x="212.4" y="-270" font-family="Times,serif" font-size="14.00">是字母?</text>
</g>
<!-- state0&#45;&gt;check0_letter -->
<g id="edge6" class="edge">
<title>state0-&gt;check0_letter</title>
<path fill="none" stroke="black" d="M277.52,-347.67C265.03,-333.77 245.93,-312.52 231.65,-296.62"></path>
<polygon fill="black" stroke="black" points="234.57,-294.64 225.29,-289.54 229.37,-299.32 234.57,-294.64"></polygon>
<text text-anchor="middle" x="263.65" y="-314.4" font-family="Times,serif" font-size="14.00">是</text>
</g>
<!-- check1_valid -->
<g id="node9" class="node">
<title>check1_valid</title>
<polygon fill="none" stroke="black" points="303.4,-203.4 220.27,-185.4 303.4,-167.4 386.52,-185.4 303.4,-203.4"></polygon>
<text text-anchor="middle" x="303.4" y="-181.2" font-family="Times,serif" font-size="14.00">是字母或数字?</text>
</g>
<!-- state1&#45;&gt;check1_valid -->
<g id="edge12" class="edge">
<title>state1-&gt;check1_valid</title>
<path fill="none" stroke="black" d="M348.82,-258.08C340.59,-245.09 328.56,-226.12 318.95,-210.95"></path>
<polygon fill="black" stroke="black" points="322.17,-209.49 313.86,-202.92 316.26,-213.24 322.17,-209.49"></polygon>
<text text-anchor="middle" x="341.65" y="-225.6" font-family="Times,serif" font-size="14.00">是</text>
</g>
<!-- error -->
<g id="node13" class="node">
<title>error</title>
<polygon fill="none" stroke="black" points="443.4,-36 385.4,-36 385.4,0 443.4,0 443.4,-36"></polygon>
<text text-anchor="middle" x="414.4" y="-13.8" font-family="Times,serif" font-size="14.00">词法错误</text>
</g>
<!-- state1&#45;&gt;error -->
<g id="edge13" class="edge">
<title>state1-&gt;error</title>
<path fill="none" stroke="black" d="M368.58,-258.15C377.27,-244.49 389.3,-223.48 395.4,-203.4 411.58,-150.14 414.57,-84.68 414.81,-47.82"></path>
<polygon fill="black" stroke="black" points="418.31,-47.98 414.8,-37.98 411.31,-47.98 418.31,-47.98"></polygon>
<text text-anchor="middle" x="414.65" y="-136.8" font-family="Times,serif" font-size="14.00">否</text>
</g>
<!-- check0_digit -->
<g id="node8" class="node">
<title>check0_digit</title>
<polygon fill="none" stroke="black" points="52.4,-203.4 0,-185.4 52.4,-167.4 104.8,-185.4 52.4,-203.4"></polygon>
<text text-anchor="middle" x="52.4" y="-181.2" font-family="Times,serif" font-size="14.00">是数字?</text>
</g>
<!-- check0_letter&#45;&gt;check0_digit -->
<g id="edge9" class="edge">
<title>check0_letter-&gt;check0_digit</title>
<path fill="none" stroke="black" d="M192.78,-262.56C165.07,-247.52 114.25,-219.96 81.96,-202.44"></path>
<polygon fill="black" stroke="black" points="83.97,-199.54 73.51,-197.85 80.63,-205.7 83.97,-199.54"></polygon>
<text text-anchor="middle" x="152.65" y="-225.6" font-family="Times,serif" font-size="14.00">否</text>
</g>
<!-- to_state1 -->
<g id="node10" class="node">
<title>to_state1</title>
<polygon fill="none" stroke="black" points="223.17,-114.6 159.62,-114.6 159.62,-73 223.17,-73 223.17,-114.6"></polygon>
<text text-anchor="middle" x="191.4" y="-98" font-family="Times,serif" font-size="14.00">state = 1</text>
<text text-anchor="middle" x="191.4" y="-81.2" font-family="Times,serif" font-size="14.00">pos++</text>
</g>
<!-- check0_letter&#45;&gt;to_state1 -->
<g id="edge8" class="edge">
<title>check0_letter-&gt;to_state1</title>
<path fill="none" stroke="black" d="M209.35,-256.89C206.8,-242.78 203.21,-221.8 200.9,-203.4 197.63,-177.42 195.12,-147.79 193.5,-126.06"></path>
<polygon fill="black" stroke="black" points="197.01,-126.1 192.8,-116.37 190.03,-126.6 197.01,-126.1"></polygon>
<text text-anchor="middle" x="206.65" y="-181.2" font-family="Times,serif" font-size="14.00">是</text>
</g>
<!-- to_state2 -->
<g id="node11" class="node">
<title>to_state2</title>
<polygon fill="none" stroke="black" points="118.17,-114.6 54.62,-114.6 54.62,-73 118.17,-73 118.17,-114.6"></polygon>
<text text-anchor="middle" x="86.4" y="-98" font-family="Times,serif" font-size="14.00">state = 2</text>
<text text-anchor="middle" x="86.4" y="-81.2" font-family="Times,serif" font-size="14.00">pos++</text>
</g>
<!-- check0_digit&#45;&gt;to_state2 -->
<g id="edge10" class="edge">
<title>check0_digit-&gt;to_state2</title>
<path fill="none" stroke="black" d="M50.13,-167.98C49.34,-157.51 49.54,-143.84 53.9,-132.6 55,-129.75 56.42,-126.96 58.05,-124.28"></path>
<polygon fill="black" stroke="black" points="60.78,-126.48 63.76,-116.31 55.09,-122.4 60.78,-126.48"></polygon>
<text text-anchor="middle" x="59.65" y="-136.8" font-family="Times,serif" font-size="14.00">是</text>
</g>
<!-- check0_digit&#45;&gt;to_state2 -->
<g id="edge11" class="edge">
<title>check0_digit-&gt;to_state2</title>
<path fill="none" stroke="black" d="M58.17,-169.2C62.69,-157.26 69.15,-140.25 74.74,-125.51"></path>
<polygon fill="black" stroke="black" points="78,-126.81 78.27,-116.22 71.45,-124.32 78,-126.81"></polygon>
<text text-anchor="middle" x="77.65" y="-136.8" font-family="Times,serif" font-size="14.00">否</text>
</g>
<!-- check1_valid&#45;&gt;to_state1 -->
<g id="edge15" class="edge">
<title>check1_valid-&gt;to_state1</title>
<path fill="none" stroke="black" d="M286.39,-170.79C270.25,-157.89 245.55,-138.12 225.38,-121.99"></path>
<polygon fill="black" stroke="black" points="227.66,-119.33 217.66,-115.81 223.28,-124.79 227.66,-119.33"></polygon>
<text text-anchor="middle" x="263.65" y="-136.8" font-family="Times,serif" font-size="14.00">是</text>
</g>
<!-- accept -->
<g id="node12" class="node">
<title>accept</title>
<polygon fill="none" stroke="black" points="526.62,-114.6 442.18,-114.6 442.18,-73 526.62,-73 526.62,-114.6"></polygon>
<text text-anchor="middle" x="484.4" y="-98" font-family="Times,serif" font-size="14.00">接受标识符</text>
<text text-anchor="middle" x="484.4" y="-81.2" font-family="Times,serif" font-size="14.00">返回TOKEN</text>
</g>
<!-- check1_valid&#45;&gt;accept -->
<g id="edge14" class="edge">
<title>check1_valid-&gt;accept</title>
<path fill="none" stroke="black" d="M321.39,-170.8C336.85,-159.54 360.04,-143.65 381.9,-132.6 397.59,-124.66 415.35,-117.52 431.63,-111.63"></path>
<polygon fill="black" stroke="black" points="432.39,-115.08 440.66,-108.45 430.06,-108.48 432.39,-115.08"></polygon>
<text text-anchor="middle" x="386.65" y="-136.8" font-family="Times,serif" font-size="14.00">否</text>
</g>
<!-- to_state1&#45;&gt;read -->
<g id="edge16" class="edge">
<title>to_state1-&gt;read</title>
<path fill="none" stroke="black" d="M168.42,-114.81C151.85,-131.54 132.4,-157.02 132.4,-184.4 132.4,-452.8 132.4,-452.8 132.4,-452.8 132.4,-486.95 233.3,-507.87 295.22,-517.49"></path>
<polygon fill="black" stroke="black" points="294.39,-520.91 304.8,-518.93 295.43,-513.99 294.39,-520.91"></polygon>
</g>
<!-- to_state2&#45;&gt;error -->
<g id="edge17" class="edge">
<title>to_state2-&gt;error</title>
<path fill="none" stroke="black" d="M118.45,-82.21C128.61,-79.03 139.92,-75.69 150.4,-73 228.97,-52.86 322.21,-35.23 374.21,-25.95"></path>
<polygon fill="black" stroke="black" points="374.55,-29.44 383.79,-24.25 373.33,-22.55 374.55,-29.44"></polygon>
</g>
<!-- accept&#45;&gt;init -->
<g id="edge18" class="edge">
<title>accept-&gt;init</title>
<path fill="none" stroke="black" d="M484.4,-115.08C484.4,-133.24 484.4,-160.6 484.4,-184.4 484.4,-525.8 484.4,-525.8 484.4,-525.8 484.4,-539.6 484.4,-554.7 484.4,-568.15"></path>
<polygon fill="black" stroke="black" points="480.9,-567.96 484.4,-577.96 487.9,-567.96 480.9,-567.96"></polygon>
</g>
<!-- error&#45;&gt;init -->
<g id="edge19" class="edge">
<title>error-&gt;init</title>
<path fill="none" stroke="black" d="M443.75,-21.53C484.8,-26.86 554.4,-43.21 554.4,-92.8 554.4,-525.8 554.4,-525.8 554.4,-525.8 554.4,-547.15 540.54,-565.78 525.16,-579.87"></path>
<polygon fill="black" stroke="black" points="523.02,-577.09 517.68,-586.25 527.56,-582.42 523.02,-577.09"></polygon>
</g>
</g>
</svg>
</p><p>对应的C语言代码框架：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-enum">enum</span> <span class="token class-name">State</span> <span class="token punctuation">{</span> START <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> IDENT <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> ERROR <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-enum">enum</span> <span class="token class-name">CharClass</span> <span class="token punctuation">{</span> LETTER<span class="token punctuation">,</span> DIGIT<span class="token punctuation">,</span> OTHER <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">get_char_class</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">isalpha</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span> LETTER<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span> DIGIT<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> OTHER<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Token <span class="token function">get_next_token</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    State state <span class="token operator">=</span> START<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> buffer<span class="token punctuation">[</span>MAX_TOKEN_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-char">char</span> ch <span class="token operator">=</span> <span class="token function">get_next_char</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> IDENT<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                buffer<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-return">return</span> <span class="token function">make_token</span><span class="token punctuation">(</span>IDENTIFIER<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-return">return</span> <span class="token function">make_token</span><span class="token punctuation">(</span>EOF_TOKEN<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword keyword-switch">switch</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-case">case</span> START<span class="token operator">:</span>
                <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">isalpha</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    state <span class="token operator">=</span> IDENT<span class="token punctuation">;</span>
                    buffer<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
                    state <span class="token operator">=</span> ERROR<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
                
            <span class="token keyword keyword-case">case</span> IDENT<span class="token operator">:</span>
                <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">isalnum</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    buffer<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
                    buffer<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
                    <span class="token function">unget_char</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword keyword-return">return</span> <span class="token function">make_token</span><span class="token punctuation">(</span>IDENTIFIER<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
                
            <span class="token keyword keyword-case">case</span> ERROR<span class="token operator">:</span>
                <span class="token keyword keyword-return">return</span> <span class="token function">make_token</span><span class="token punctuation">(</span>ERROR_TOKEN<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>另外，如果DFA比较复杂，也可以用状态转移表的方式实现：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 状态转移表</span>
<span class="token keyword keyword-int">int</span> trans_table<span class="token punctuation">[</span>STATE_NUM<span class="token punctuation">]</span><span class="token punctuation">[</span>CHAR_CLASS_NUM<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// LETTER  DIGIT  OTHER</span>
    <span class="token punctuation">{</span>  IDENT<span class="token punctuation">,</span>  ERROR<span class="token punctuation">,</span> ERROR <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// START</span>
    <span class="token punctuation">{</span>  IDENT<span class="token punctuation">,</span>  IDENT<span class="token punctuation">,</span> ERROR <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// IDENT</span>
    <span class="token punctuation">{</span>  ERROR<span class="token punctuation">,</span>  ERROR<span class="token punctuation">,</span> ERROR <span class="token punctuation">}</span>   <span class="token comment">// ERROR</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 状态类型表</span>
<span class="token keyword keyword-int">int</span> state_type<span class="token punctuation">[</span>STATE_NUM<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    NON_ACCEPT<span class="token punctuation">,</span>  <span class="token comment">// START</span>
    ACCEPT<span class="token punctuation">,</span>      <span class="token comment">// IDENT</span>
    ERROR        <span class="token comment">// ERROR</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Token <span class="token function">get_next_token</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    State state <span class="token operator">=</span> START<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> buffer<span class="token punctuation">[</span>MAX_TOKEN_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-char">char</span> ch <span class="token operator">=</span> <span class="token function">get_next_char</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>state_type<span class="token punctuation">[</span>state<span class="token punctuation">]</span> <span class="token operator">==</span> ACCEPT<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                buffer<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-return">return</span> <span class="token function">make_token</span><span class="token punctuation">(</span>IDENTIFIER<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-return">return</span> <span class="token function">make_token</span><span class="token punctuation">(</span>EOF_TOKEN<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword keyword-int">int</span> char_class <span class="token operator">=</span> <span class="token function">get_char_class</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
        State next_state <span class="token operator">=</span> trans_table<span class="token punctuation">[</span>state<span class="token punctuation">]</span><span class="token punctuation">[</span>char_class<span class="token punctuation">]</span><span class="token punctuation">;</span>
        
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>next_state <span class="token operator">==</span> ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>state_type<span class="token punctuation">[</span>state<span class="token punctuation">]</span> <span class="token operator">==</span> ACCEPT<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                buffer<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
                <span class="token function">unget_char</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-return">return</span> <span class="token function">make_token</span><span class="token punctuation">(</span>IDENTIFIER<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-return">return</span> <span class="token function">make_token</span><span class="token punctuation">(</span>ERROR_TOKEN<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        buffer<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span>
        state <span class="token operator">=</span> next_state<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>转换过程的主要考虑点：</p>
<ol>
<li>
<p>状态表示</p>
<ul>
<li>使用枚举类型表示状态</li>
<li>使用状态转移表</li>
<li>状态类型表（接受/非接受）</li>
</ul>
</li>
<li>
<p>输入处理</p>
<ul>
<li>缓冲区管理</li>
<li>回退机制</li>
<li>EOF处理</li>
</ul>
</li>
<li>
<p>错误处理</p>
<ul>
<li>错误状态的识别</li>
<li>错误恢复策略</li>
<li>错误信息的生成</li>
</ul>
</li>
<li>
<p>标记生成</p>
<ul>
<li>标记类型的定义</li>
<li>属性值的收集</li>
<li>符号表的管理</li>
</ul>
</li>
<li>
<p>优化考虑</p>
<ul>
<li>表驱动还是switch-case</li>
<li>缓冲区策略</li>
<li>状态合并</li>
</ul>
</li>
</ol>
<p>这样的转换方法具有以下优点：</p>
<ol>
<li>结构清晰，便于维护</li>
<li>易于扩展和修改</li>
<li>运行效率高</li>
<li>错误处理完善</li>
</ol>
<hr>
<p><code>buffer</code>是用来存储当前正在识别的词素（lexeme）的字符缓冲区。让我详细解释一下它的作用：</p>
<ol>
<li>基本功能
<ul>
<li>存储输入字符流中正在识别的词素</li>
<li>最终用于构造词法单元的属性值</li>
<li>便于回溯和错误处理</li>
</ul>
</li>
</ol>
<p>举个例子，假设输入字符串是：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>int abc = 123;
</code></pre><p>在识别标识符<code>abc</code>时的过程：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> ch <span class="token operator">=</span> <span class="token function">get_next_char</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 依次读入'a'、'b'、'c'</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">isalnum</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        buffer<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span>     <span class="token comment">// buffer中依次存入"a"、"ab"、"abc"</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>  <span class="token comment">// 遇到空格</span>
        buffer<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>     <span class="token comment">// 在buffer末尾加上字符串结束符</span>
        <span class="token keyword keyword-return">return</span> <span class="token function">make_token</span><span class="token punctuation">(</span>IDENTIFIER<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回标识符token，值为"abc"</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>我们可以用一个更完整的例子来说明：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_TOKEN_LEN</span> <span class="token expression"><span class="token number">1024</span></span></span>

<span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-struct">struct</span> <span class="token punctuation">{</span>
    TokenType type<span class="token punctuation">;</span>    <span class="token comment">// 词法单元类型</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>lexeme<span class="token punctuation">;</span>      <span class="token comment">// 词素字符串</span>
    <span class="token keyword keyword-int">int</span> line<span class="token punctuation">;</span>          <span class="token comment">// 行号</span>
    <span class="token comment">// 其他属性...</span>
<span class="token punctuation">}</span> Token<span class="token punctuation">;</span>

Token <span class="token function">get_next_token</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    State state <span class="token operator">=</span> START<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// buffer中的当前位置</span>
    <span class="token keyword keyword-char">char</span> buffer<span class="token punctuation">[</span>MAX_TOKEN_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 词素缓冲区</span>
    
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-char">char</span> ch <span class="token operator">=</span> <span class="token function">get_next_char</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword keyword-switch">switch</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-case">case</span> START<span class="token operator">:</span>
                <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">isalpha</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 遇到字母</span>
                    state <span class="token operator">=</span> IDENT<span class="token punctuation">;</span>
                    buffer<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span>  <span class="token comment">// 保存到buffer</span>
                <span class="token punctuation">}</span>
                <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 遇到数字</span>
                    state <span class="token operator">=</span> NUMBER<span class="token punctuation">;</span>
                    buffer<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span>  <span class="token comment">// 保存到buffer</span>
                <span class="token punctuation">}</span>
                <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token char">'"'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 遇到引号</span>
                    state <span class="token operator">=</span> STRING<span class="token punctuation">;</span>
                    buffer<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span>  <span class="token comment">// 保存到buffer</span>
                <span class="token punctuation">}</span>
                <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
                
            <span class="token keyword keyword-case">case</span> IDENT<span class="token operator">:</span>
                <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">isalnum</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    buffer<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span>  <span class="token comment">// 继续保存字符</span>
                <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
                    buffer<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>  <span class="token comment">// 结束字符串</span>
                    <span class="token function">unget_char</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 字符回退</span>
                    
                    <span class="token comment">// 检查是否是关键字</span>
                    TokenType type <span class="token operator">=</span> <span class="token function">is_keyword</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token operator">?</span> 
                                   <span class="token function">get_keyword_type</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token operator">:</span> IDENTIFIER<span class="token punctuation">;</span>
                    
                    <span class="token comment">// 创建新的词法单元</span>
                    <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>Token<span class="token punctuation">)</span><span class="token punctuation">{</span>
                        <span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">,</span>
                        <span class="token punctuation">.</span>lexeme <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 复制buffer内容</span>
                        <span class="token punctuation">.</span>line <span class="token operator">=</span> current_line
                    <span class="token punctuation">}</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
                
            <span class="token keyword keyword-case">case</span> NUMBER<span class="token operator">:</span>
                <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    buffer<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span>  <span class="token comment">// 继续保存数字</span>
                <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token char">'.'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    state <span class="token operator">=</span> FLOAT<span class="token punctuation">;</span>
                    buffer<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span>  <span class="token comment">// 保存小数点</span>
                <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
                    buffer<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
                    <span class="token function">unget_char</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>Token<span class="token punctuation">)</span><span class="token punctuation">{</span>
                        <span class="token punctuation">.</span>type <span class="token operator">=</span> INTEGER<span class="token punctuation">,</span>
                        <span class="token punctuation">.</span>lexeme <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">,</span>
                        <span class="token punctuation">.</span>line <span class="token operator">=</span> current_line
                    <span class="token punctuation">}</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
                
            <span class="token keyword keyword-case">case</span> STRING<span class="token operator">:</span>
                buffer<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span>
                <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token char">'"'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 字符串结束</span>
                    buffer<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
                    <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>Token<span class="token punctuation">)</span><span class="token punctuation">{</span>
                        <span class="token punctuation">.</span>type <span class="token operator">=</span> STRING_LITERAL<span class="token punctuation">,</span>
                        <span class="token punctuation">.</span>lexeme <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">,</span>
                        <span class="token punctuation">.</span>line <span class="token operator">=</span> current_line
                    <span class="token punctuation">}</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// 检查buffer是否溢出</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>pos <span class="token operator">&gt;=</span> MAX_TOKEN_LEN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">lexical_error</span><span class="token punctuation">(</span><span class="token string">"Token too long"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>在这个例子中，<code>buffer</code>的主要作用有：</p>
<ol>
<li>
<p>暂存功能</p>
<ul>
<li>在词法分析过程中暂存已读入的字符</li>
<li>直到确认词素的边界（遇到分隔符或状态转换）</li>
<li>便于构造完整的词素字符串</li>
</ul>
</li>
<li>
<p>关键字识别</p>
<ul>
<li>存储完整的标识符字符串</li>
<li>用于查找是否是关键字</li>
<li>确定最终的词法单元类型</li>
</ul>
</li>
<li>
<p>错误处理</p>
<ul>
<li>记录出错位置的上下文</li>
<li>提供错误信息和诊断</li>
<li>便于错误恢复</li>
</ul>
</li>
<li>
<p>属性值收集</p>
<ul>
<li>为词法单元提供属性值</li>
<li>用于后续的语法分析和语义分析</li>
<li>保存到符号表中</li>
</ul>
</li>
<li>
<p>输入回溯</p>
<ul>
<li>在需要回退的情况下保留已读取的内容</li>
<li>支持超前扫描</li>
<li>处理词素边界</li>
</ul>
</li>
</ol>
<p><code>buffer</code>的使用技巧：</p>
<ol>
<li>
<p>大小选择</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_TOKEN_LEN</span> <span class="token expression"><span class="token number">1024</span>  </span><span class="token comment">// 根据实际需求设置</span></span>
</code></pre></li>
<li>
<p>溢出检查</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>pos <span class="token operator">&gt;=</span> MAX_TOKEN_LEN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">lexical_error</span><span class="token punctuation">(</span><span class="token string">"Token too long"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li>
<li>
<p>字符串处理</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>buffer<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>  <span class="token comment">// 添加字符串结束符</span>
<span class="token keyword keyword-char">char</span> <span class="token operator">*</span>lexeme <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 复制到堆内存</span>
</code></pre></li>
<li>
<p>回退处理</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token function">unget_char</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 字符回退</span>
buffer<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>  <span class="token comment">// 当前位置结束</span>
</code></pre></li>
</ol>
<p>总的来说，<code>buffer</code>是词法分析器中的一个重要组件，它帮助我们完成从字符流到词法单元的转换过程。</p>
<hr>
<p>词法单元的类型（token type）是用来标识词素属于哪一类语言元素的标签。我来详细讲解一下。</p>
<p>在编程语言中，常见的词法单元类型包括：</p>
<ol>
<li>
<p>标识符（identifier）：变量名、函数名等</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// count是标识符</span>
<span class="token keyword keyword-void">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// test是标识符</span>
</code></pre></li>
<li>
<p>关键字（keyword）：语言预定义的特殊词</p>
<ul>
<li><code>if</code>、<code>while</code>、<code>for</code>、<code>int</code>、<code>return</code>等</li>
<li>关键字通常有固定的列表，每个都是独立的类型</li>
<li>比如<code>&lt;if&gt;</code>、<code>&lt;while&gt;</code>、<code>&lt;int&gt;</code>等</li>
</ul>
</li>
<li>
<p>运算符（operator）：</p>
<ul>
<li>算术运算：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code></li>
<li>关系运算：<code>&lt;</code>、<code>&gt;</code>、<code>==</code>、<code>!=</code></li>
<li>逻辑运算：<code>&amp;&amp;</code>、<code>||</code>、<code>!</code></li>
<li>赋值运算：<code>=</code>、<code>+=</code>、<code>-=</code></li>
</ul>
</li>
<li>
<p>分隔符（delimiter）：</p>
<ul>
<li>括号：<code>(</code>、<code>)</code>、<code>{</code>、<code>}</code>、<code>[</code>、<code>]</code></li>
<li>标点：<code>;</code>、<code>,</code>、<code>.</code></li>
</ul>
</li>
<li>
<p>常量（literal）：</p>
<ul>
<li>整数：<code>&lt;integer_lit, "42"&gt;</code></li>
<li>浮点数：<code>&lt;float_lit, "3.14"&gt;</code></li>
<li>字符：<code>&lt;char_lit, "A"&gt;</code></li>
<li>字符串：<code>&lt;string_lit, "hello"&gt;</code></li>
</ul>
</li>
</ol>
<p>举个具体例子，看看这段代码如何被分解成词法单元：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sum <span class="token operator">+=</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>对应的词法单元序列是：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>&lt;while&gt;
&lt;lparen&gt;
&lt;id, "x"&gt;
&lt;leq&gt;           // 小于等于运算符
&lt;integer_lit, "100"&gt;
&lt;rparen&gt;
&lt;lbrace&gt;
&lt;id, "sum"&gt;
&lt;pluseq&gt;        // +=运算符
&lt;id, "x"&gt;
&lt;mult&gt;          // 乘法运算符
&lt;integer_lit, "2"&gt;
&lt;semicolon&gt;
&lt;rbrace&gt;
</code></pre><p>在实际编译器中，这些类型通常用枚举或整数常量来表示：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-enum">enum</span> <span class="token class-name">TokenType</span> <span class="token punctuation">{</span>
    TOK_ID<span class="token punctuation">,</span>         <span class="token comment">// 标识符</span>
    TOK_INT_LIT<span class="token punctuation">,</span>    <span class="token comment">// 整数常量</span>
    TOK_FLOAT_LIT<span class="token punctuation">,</span>  <span class="token comment">// 浮点数常量</span>
    TOK_STRING_LIT<span class="token punctuation">,</span> <span class="token comment">// 字符串常量</span>
    TOK_PLUS<span class="token punctuation">,</span>       <span class="token comment">// +</span>
    TOK_MINUS<span class="token punctuation">,</span>      <span class="token comment">// -</span>
    TOK_MULT<span class="token punctuation">,</span>       <span class="token comment">// *</span>
    TOK_DIV<span class="token punctuation">,</span>        <span class="token comment">// /</span>
    TOK_EQ<span class="token punctuation">,</span>         <span class="token comment">// ==</span>
    TOK_ASSIGN<span class="token punctuation">,</span>     <span class="token comment">// =</span>
    TOK_SEMICOLON<span class="token punctuation">,</span>  <span class="token comment">// ;</span>
    TOK_IF<span class="token punctuation">,</span>         <span class="token comment">// if关键字</span>
    TOK_WHILE<span class="token punctuation">,</span>      <span class="token comment">// while关键字</span>
    <span class="token comment">// ...其他类型</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>这种类型信息对后续的语法分析非常重要：</p>
<ol>
<li>帮助语法分析器判断当前读到的是什么语言元素</li>
<li>验证语法规则是否正确</li>
<li>指导语法树的构建</li>
</ol>
<p>比如当语法分析器看到：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
</code></pre><p>它知道：</p>
<ul>
<li><code>if</code>的类型是<code>TOK_IF</code>，说明这是一个条件语句的开始</li>
<li><code>(</code>的类型是<code>TOK_LPAREN</code>，符合<code>if</code>语句的语法要求</li>
<li><code>x</code>的类型是<code>TOK_ID</code>，说明这是一个变量</li>
<li><code>&gt;</code>的类型是<code>TOK_GT</code>，说明这是一个关系运算符</li>
<li><code>0</code>的类型是<code>TOK_INT_LIT</code>，说明这是一个整数常量</li>
<li><code>)</code>的类型是<code>TOK_RPAREN</code>，说明条件表达式结束</li>
</ul>
<p>通过这些类型信息，语法分析器就能正确地构建出表示这个<code>if</code>语句的语法树节点。</p>
<hr>
<p>让我系统地整理一下对词法单元类型的编码方式。</p>
<p>在编译器中，根据不同类型词法单元的特点，采用了不同的编码策略：</p>
<ol>
<li>
<p>独立编码<br>
为每个具体的符号分配唯一的类型码，适用于数量有限且固定的符号：</p>
<ul>
<li>运算符：每个运算符都有唯一编码<pre data-role="codeBlock" data-info="c" class="language-c c"><code>TOK_PLUS<span class="token punctuation">,</span>    <span class="token comment">// +</span>
TOK_MINUS<span class="token punctuation">,</span>   <span class="token comment">// -</span>
TOK_MULT<span class="token punctuation">,</span>    <span class="token comment">// *</span>
TOK_DIV<span class="token punctuation">,</span>     <span class="token comment">// /</span>
TOK_GT<span class="token punctuation">,</span>      <span class="token comment">// &gt;</span>
TOK_LT<span class="token punctuation">,</span>      <span class="token comment">// &lt;</span>
TOK_EQ<span class="token punctuation">,</span>      <span class="token comment">// ==</span>
TOK_NE<span class="token punctuation">,</span>      <span class="token comment">// !=</span>
</code></pre></li>
<li>分隔符：每个分隔符都有唯一编码<pre data-role="codeBlock" data-info="c" class="language-c c"><code>TOK_LPAREN<span class="token punctuation">,</span>  <span class="token comment">// (</span>
TOK_RPAREN<span class="token punctuation">,</span>  <span class="token comment">// )</span>
TOK_LBRACE<span class="token punctuation">,</span>  <span class="token comment">// {</span>
TOK_RBRACE<span class="token punctuation">,</span>  <span class="token comment">// }</span>
TOK_COMMA<span class="token punctuation">,</span>   <span class="token comment">// ,</span>
TOK_SEMI<span class="token punctuation">,</span>    <span class="token comment">// ;</span>
</code></pre></li>
<li>关键字：每个关键字都有唯一编码<pre data-role="codeBlock" data-info="c" class="language-c c"><code>TOK_IF<span class="token punctuation">,</span>      <span class="token comment">// if</span>
TOK_ELSE<span class="token punctuation">,</span>    <span class="token comment">// else</span>
TOK_WHILE<span class="token punctuation">,</span>   <span class="token comment">// while</span>
TOK_FOR<span class="token punctuation">,</span>     <span class="token comment">// for</span>
TOK_RETURN<span class="token punctuation">,</span>  <span class="token comment">// return</span>
TOK_INT<span class="token punctuation">,</span>     <span class="token comment">// int</span>
TOK_FLOAT<span class="token punctuation">,</span>   <span class="token comment">// float</span>
</code></pre></li>
</ul>
</li>
<li>
<p>统一编码<br>
用同一个类型码表示同一类的所有符号，主要用于标识符：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>TOK_ID        <span class="token comment">// 所有标识符都用这一个类型表示</span>
</code></pre><p>比如下面的代码中的所有标识符：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> count<span class="token punctuation">;</span>
<span class="token keyword keyword-float">float</span> average<span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>都用<code>TOK_ID</code>表示，具体是哪个标识符则记录在词法单元的值部分。</p>
</li>
<li>
<p>分类编码<br>
按照符号的性质进行分类，每类使用一个类型码，主要用于常量：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>TOK_INT_LIT<span class="token punctuation">,</span>    <span class="token comment">// 整数常量</span>
TOK_FLOAT_LIT<span class="token punctuation">,</span>  <span class="token comment">// 浮点数常量</span>
TOK_CHAR_LIT<span class="token punctuation">,</span>   <span class="token comment">// 字符常量</span>
TOK_STRING_LIT  <span class="token comment">// 字符串常量</span>
</code></pre></li>
</ol>
<p>让我们看一个具体的例子，这段代码被词法分析后会得到怎样的token序列：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword keyword-float">float</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Too large!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>对应的词法单元序列是：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>&lt;TOK_INT&gt;         // 独立编码（关键字）
&lt;TOK_ID, "sum"&gt;   // 统一编码（标识符）
&lt;TOK_ASSIGN&gt;      // 独立编码（运算符）
&lt;TOK_INT_LIT, "0"&gt;// 分类编码（整数常量）
&lt;TOK_SEMI&gt;        // 独立编码（分隔符）
&lt;TOK_FLOAT&gt;       // 独立编码（关键字）
&lt;TOK_ID, "pi"&gt;    // 统一编码（标识符）
&lt;TOK_ASSIGN&gt;      // 独立编码（运算符）
&lt;TOK_FLOAT_LIT, "3.14"&gt;  // 分类编码（浮点数常量）
&lt;TOK_SEMI&gt;        // 独立编码（分隔符）
&lt;TOK_IF&gt;          // 独立编码（关键字）
&lt;TOK_LPAREN&gt;      // 独立编码（分隔符）
&lt;TOK_ID, "sum"&gt;   // 统一编码（标识符）
&lt;TOK_GT&gt;          // 独立编码（运算符）
&lt;TOK_INT_LIT, "100"&gt;  // 分类编码（整数常量）
&lt;TOK_RPAREN&gt;      // 独立编码（分隔符）
&lt;TOK_LBRACE&gt;      // 独立编码（分隔符）
&lt;TOK_ID, "printf"&gt;    // 统一编码（标识符）
&lt;TOK_LPAREN&gt;      // 独立编码（分隔符）
&lt;TOK_STRING_LIT, "Too large!"&gt;  // 分类编码（字符串常量）
&lt;TOK_RPAREN&gt;      // 独立编码（分隔符）
&lt;TOK_SEMI&gt;        // 独立编码（分隔符）
&lt;TOK_RBRACE&gt;      // 独立编码（分隔符）
</code></pre><p>这种编码方式的优点是：</p>
<ol>
<li>对于固定的符号（独立编码），可以直接用类型来区分，处理简单</li>
<li>对于可变的符号（统一编码和分类编码），通过合适的分类既节省了类型编码的数量，又保留了足够的识别信息</li>
<li>配合词法单元的值部分，能够完整地保存源代码中的所有必要信息</li>
</ol>
<hr>
<p>词法单元的值部分（attribute value）用于存储除了类型之外的额外信息。</p>
<p>首先，根据词法单元类型的不同，值信息的存储需求也不同：</p>
<ol>
<li>
<p>独立编码的词法单元（不需要值信息）</p>
<ul>
<li>运算符如<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code></li>
<li>关键字如<code>if</code>、<code>while</code>、<code>int</code></li>
<li>分隔符如<code>(</code>、<code>)</code>、<code>;</code>、<code>,</code></li>
</ul>
<p>这些符号本身就包含了所有信息，类型就足够表达它们了。</p>
</li>
<li>
<p>统一编码的词法单元（需要值信息）<br>
标识符有两种表示方式：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 方式一：直接存储字符串</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">Token</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-int">int</span> type<span class="token punctuation">;</span>           <span class="token comment">// TOK_ID</span>
  <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>lexeme<span class="token punctuation">;</span>       <span class="token comment">// 存储标识符字符串</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 方式二：使用符号表指针</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">Token</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-int">int</span> type<span class="token punctuation">;</span>           <span class="token comment">// TOK_ID</span>
  <span class="token keyword keyword-int">int</span> symtab_index<span class="token punctuation">;</span>   <span class="token comment">// 符号表中的索引</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></li>
<li>
<p>分类编码的词法单元（需要值信息）<br>
常量也有两种表示方式：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 方式一：直接存储值</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">Token</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-int">int</span> type<span class="token punctuation">;</span>           <span class="token comment">// TOK_INT_LIT等</span>
  <span class="token keyword keyword-union">union</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> int_val<span class="token punctuation">;</span>
    <span class="token keyword keyword-float">float</span> float_val<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> char_val<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>str_val<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 方式二：使用常量表指针</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">Token</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-int">int</span> type<span class="token punctuation">;</span>           <span class="token comment">// TOK_INT_LIT等</span>
  <span class="token keyword keyword-int">int</span> const_index<span class="token punctuation">;</span>    <span class="token comment">// 常量表中的索引</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></li>
</ol>
<p>让我们看一个具体例子：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> count <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword keyword-float">float</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token keyword keyword-char">char</span> <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
</code></pre><p>使用内码（直接存储）方式的词法单元序列：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">Token</span> tokens<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>TOK_INT<span class="token punctuation">}</span><span class="token punctuation">,</span>                    <span class="token comment">// int（不需要值）</span>
    <span class="token punctuation">{</span>TOK_ID<span class="token punctuation">,</span> <span class="token string">"count"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>           <span class="token comment">// count（存储字符串）</span>
    <span class="token punctuation">{</span>TOK_ASSIGN<span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token comment">// =（不需要值）</span>
    <span class="token punctuation">{</span>TOK_INT_LIT<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>int_val<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 42（存储整数值）</span>
    <span class="token punctuation">{</span>TOK_SEMI<span class="token punctuation">}</span><span class="token punctuation">,</span>                  <span class="token comment">// ;（不需要值）</span>
    <span class="token punctuation">{</span>TOK_FLOAT<span class="token punctuation">}</span><span class="token punctuation">,</span>                 <span class="token comment">// float（不需要值）</span>
    <span class="token punctuation">{</span>TOK_ID<span class="token punctuation">,</span> <span class="token string">"pi"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>             <span class="token comment">// pi（存储字符串）</span>
    <span class="token punctuation">{</span>TOK_ASSIGN<span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token comment">// =（不需要值）</span>
    <span class="token punctuation">{</span>TOK_FLOAT_LIT<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>float_val<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 3.14（存储浮点值）</span>
    <span class="token punctuation">{</span>TOK_SEMI<span class="token punctuation">}</span><span class="token punctuation">,</span>                  <span class="token comment">// ;（不需要值）</span>
    <span class="token punctuation">{</span>TOK_CHAR<span class="token punctuation">}</span><span class="token punctuation">,</span>                  <span class="token comment">// char（不需要值）</span>
    <span class="token punctuation">{</span>TOK_MULT<span class="token punctuation">}</span><span class="token punctuation">,</span>                  <span class="token comment">// *（不需要值）</span>
    <span class="token punctuation">{</span>TOK_ID<span class="token punctuation">,</span> <span class="token string">"msg"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token comment">// msg（存储字符串）</span>
    <span class="token punctuation">{</span>TOK_ASSIGN<span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token comment">// =（不需要值）</span>
    <span class="token punctuation">{</span>TOK_STRING_LIT<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>str_val<span class="token operator">=</span><span class="token string">"hello"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// "hello"（存储字符串）</span>
    <span class="token punctuation">{</span>TOK_SEMI<span class="token punctuation">}</span>                   <span class="token comment">// ;（不需要值）</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>使用指针（索引）方式时，需要配合符号表和常量表：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 符号表</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">SymbolEntry</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> type<span class="token punctuation">;</span>
    <span class="token comment">// 其他信息...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 常量表</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">ConstEntry</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-enum">enum</span> <span class="token class-name">ConstType</span> <span class="token punctuation">{</span>INT<span class="token punctuation">,</span> FLOAT<span class="token punctuation">,</span> CHAR<span class="token punctuation">,</span> STRING<span class="token punctuation">}</span> type<span class="token punctuation">;</span>
    <span class="token keyword keyword-union">union</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-int">int</span> int_val<span class="token punctuation">;</span>
        <span class="token keyword keyword-float">float</span> float_val<span class="token punctuation">;</span>
        <span class="token keyword keyword-char">char</span> char_val<span class="token punctuation">;</span>
        <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>str_val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 词法单元序列</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">Token</span> tokens<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>TOK_INT<span class="token punctuation">}</span><span class="token punctuation">,</span>           <span class="token comment">// int</span>
    <span class="token punctuation">{</span>TOK_ID<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment">// count（符号表索引1）</span>
    <span class="token punctuation">{</span>TOK_ASSIGN<span class="token punctuation">}</span><span class="token punctuation">,</span>       <span class="token comment">// =</span>
    <span class="token punctuation">{</span>TOK_INT_LIT<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token comment">// 42（常量表索引1）</span>
    <span class="token punctuation">{</span>TOK_SEMI<span class="token punctuation">}</span><span class="token punctuation">,</span>         <span class="token comment">// ;</span>
    <span class="token punctuation">{</span>TOK_FLOAT<span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment">// float</span>
    <span class="token punctuation">{</span>TOK_ID<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment">// pi（符号表索引2）</span>
    <span class="token punctuation">{</span>TOK_ASSIGN<span class="token punctuation">}</span><span class="token punctuation">,</span>       <span class="token comment">// =</span>
    <span class="token punctuation">{</span>TOK_FLOAT_LIT<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 3.14（常量表索引2）</span>
    <span class="token punctuation">{</span>TOK_SEMI<span class="token punctuation">}</span><span class="token punctuation">,</span>         <span class="token comment">// ;</span>
    <span class="token punctuation">{</span>TOK_CHAR<span class="token punctuation">}</span><span class="token punctuation">,</span>         <span class="token comment">// char</span>
    <span class="token punctuation">{</span>TOK_MULT<span class="token punctuation">}</span><span class="token punctuation">,</span>         <span class="token comment">// *</span>
    <span class="token punctuation">{</span>TOK_ID<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment">// msg（符号表索引3）</span>
    <span class="token punctuation">{</span>TOK_ASSIGN<span class="token punctuation">}</span><span class="token punctuation">,</span>       <span class="token comment">// =</span>
    <span class="token punctuation">{</span>TOK_STRING_LIT<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment">// "hello"（常量表索引3）</span>
    <span class="token punctuation">{</span>TOK_SEMI<span class="token punctuation">}</span>          <span class="token comment">// ;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>两种方式的比较：</p>
<ol>
<li>
<p>内码方式：</p>
<ul>
<li>优点：访问快速，不需要额外的查表操作</li>
<li>缺点：可能占用较多空间，特别是字符串</li>
<li>适用：小程序或对速度要求高的场合</li>
</ul>
</li>
<li>
<p>指针方式：</p>
<ul>
<li>优点：节省空间，相同的标识符或常量只存储一次</li>
<li>优点：便于后续阶段（如语义分析）使用符号表信息</li>
<li>缺点：需要额外的查表操作</li>
<li>适用：大型程序或需要详细符号信息的场合</li>
</ul>
</li>
</ol>
<p>在实际编译器中，常常采用混合策略：</p>
<ul>
<li>对于简单的数值常量用内码</li>
<li>对于字符串和标识符用指针</li>
<li>可能会维护一个字符串池来重用相同的字符串</li>
</ul>
<p>这样可以在空间效率和访问速度之间取得平衡。</p>
<hr>
<p>让我详细讲解符号表和常量表的结构和作用。</p>
<p>符号表（Symbol Table）是用来存储标识符信息的数据结构：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">SymbolEntry</span> <span class="token punctuation">{</span>
    <span class="token comment">// 基本信息</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>         <span class="token comment">// 标识符名称</span>
    <span class="token keyword keyword-int">int</span> type<span class="token punctuation">;</span>          <span class="token comment">// 数据类型（int、float等）</span>
    <span class="token keyword keyword-int">int</span> scope<span class="token punctuation">;</span>         <span class="token comment">// 作用域级别</span>
    
    <span class="token comment">// 根据标识符种类存储的具体信息</span>
    <span class="token keyword keyword-union">union</span> <span class="token punctuation">{</span>
        <span class="token comment">// 变量信息</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-int">int</span> offset<span class="token punctuation">;</span>     <span class="token comment">// 内存偏移量</span>
            bool is_const<span class="token punctuation">;</span>  <span class="token comment">// 是否是常量</span>
        <span class="token punctuation">}</span> var_info<span class="token punctuation">;</span>
        
        <span class="token comment">// 函数信息</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-int">int</span> param_count<span class="token punctuation">;</span>    <span class="token comment">// 参数个数</span>
            <span class="token keyword keyword-int">int</span> <span class="token operator">*</span>param_types<span class="token punctuation">;</span>   <span class="token comment">// 参数类型列表</span>
            <span class="token keyword keyword-int">int</span> return_type<span class="token punctuation">;</span>    <span class="token comment">// 返回值类型</span>
        <span class="token punctuation">}</span> func_info<span class="token punctuation">;</span>
        
        <span class="token comment">// 类型信息（用于结构体、枚举等）</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-int">int</span> size<span class="token punctuation">;</span>          <span class="token comment">// 类型大小</span>
            SymbolEntry <span class="token operator">*</span>members<span class="token punctuation">;</span>  <span class="token comment">// 成员列表</span>
        <span class="token punctuation">}</span> type_info<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> info<span class="token punctuation">;</span>
    
    <span class="token comment">// 链表指针（用于处理作用域）</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">SymbolEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>常量表（Constant Table）用来存储程序中的常量值：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">ConstEntry</span> <span class="token punctuation">{</span>
    <span class="token comment">// 常量类型</span>
    <span class="token keyword keyword-enum">enum</span> <span class="token class-name">ConstType</span> <span class="token punctuation">{</span>
        CONST_INT<span class="token punctuation">,</span>
        CONST_FLOAT<span class="token punctuation">,</span>
        CONST_CHAR<span class="token punctuation">,</span>
        CONST_STRING
    <span class="token punctuation">}</span> type<span class="token punctuation">;</span>
    
    <span class="token comment">// 常量值</span>
    <span class="token keyword keyword-union">union</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-int">int</span> int_val<span class="token punctuation">;</span>
        <span class="token keyword keyword-float">float</span> float_val<span class="token punctuation">;</span>
        <span class="token keyword keyword-char">char</span> char_val<span class="token punctuation">;</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>str_val<span class="token punctuation">;</span>
            <span class="token keyword keyword-int">int</span> length<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> string_info<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> value<span class="token punctuation">;</span>
    
    <span class="token comment">// 用于优化的额外信息</span>
    bool is_used<span class="token punctuation">;</span>      <span class="token comment">// 是否被使用</span>
    <span class="token keyword keyword-int">int</span> ref_count<span class="token punctuation">;</span>     <span class="token comment">// 引用计数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>让我们通过一个例子来看它们的使用：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-int">int</span> MAX <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword keyword-struct">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-float">float</span> x<span class="token punctuation">;</span>
    <span class="token keyword keyword-float">float</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-float">float</span> <span class="token function">distance</span><span class="token punctuation">(</span>Point p1<span class="token punctuation">,</span> Point p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-float">float</span> dx <span class="token operator">=</span> p1<span class="token punctuation">.</span>x <span class="token operator">-</span> p2<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
    <span class="token keyword keyword-float">float</span> dy <span class="token operator">=</span> p1<span class="token punctuation">.</span>y <span class="token operator">-</span> p2<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>dx<span class="token operator">*</span>dx <span class="token operator">+</span> dy<span class="token operator">*</span>dy<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-char">char</span> <span class="token operator">*</span>message <span class="token operator">=</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span>
</code></pre><p>这段代码对应的符号表可能是这样的：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 全局作用域的符号表项</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">"MAX"</span><span class="token punctuation">,</span>
    type<span class="token operator">:</span> TYPE_INT<span class="token punctuation">,</span>
    scope<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    info<span class="token operator">:</span> <span class="token punctuation">{</span>
        var_info<span class="token operator">:</span> <span class="token punctuation">{</span>
            offset<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
            is_const<span class="token operator">:</span> true
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">"count"</span><span class="token punctuation">,</span>
    type<span class="token operator">:</span> TYPE_INT<span class="token punctuation">,</span>
    scope<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    info<span class="token operator">:</span> <span class="token punctuation">{</span>
        var_info<span class="token operator">:</span> <span class="token punctuation">{</span>
            offset<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
            is_const<span class="token operator">:</span> false
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">"Point"</span><span class="token punctuation">,</span>
    type<span class="token operator">:</span> TYPE_STRUCT<span class="token punctuation">,</span>
    scope<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    info<span class="token operator">:</span> <span class="token punctuation">{</span>
        type_info<span class="token operator">:</span> <span class="token punctuation">{</span>
            size<span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">,</span>
            members<span class="token operator">:</span> <span class="token punctuation">[</span>
                <span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">"x"</span><span class="token punctuation">,</span> type<span class="token operator">:</span> TYPE_FLOAT<span class="token punctuation">,</span> offset<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                <span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">"y"</span><span class="token punctuation">,</span> type<span class="token operator">:</span> TYPE_FLOAT<span class="token punctuation">,</span> offset<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">}</span>
            <span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">"distance"</span><span class="token punctuation">,</span>
    type<span class="token operator">:</span> TYPE_FUNC<span class="token punctuation">,</span>
    scope<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    info<span class="token operator">:</span> <span class="token punctuation">{</span>
        func_info<span class="token operator">:</span> <span class="token punctuation">{</span>
            param_count<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
            param_types<span class="token operator">:</span> <span class="token punctuation">[</span>TYPE_STRUCT_POINT<span class="token punctuation">,</span> TYPE_STRUCT_POINT<span class="token punctuation">]</span><span class="token punctuation">,</span>
            return_type<span class="token operator">:</span> TYPE_FLOAT
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">"message"</span><span class="token punctuation">,</span>
    type<span class="token operator">:</span> TYPE_PTR_CHAR<span class="token punctuation">,</span>
    scope<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    info<span class="token operator">:</span> <span class="token punctuation">{</span>
        var_info<span class="token operator">:</span> <span class="token punctuation">{</span>
            offset<span class="token operator">:</span> <span class="token number">12</span><span class="token punctuation">,</span>
            is_const<span class="token operator">:</span> false
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// distance函数内的局部变量</span>
<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">"dx"</span><span class="token punctuation">,</span>
    type<span class="token operator">:</span> TYPE_FLOAT<span class="token punctuation">,</span>
    scope<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    info<span class="token operator">:</span> <span class="token punctuation">{</span>
        var_info<span class="token operator">:</span> <span class="token punctuation">{</span>
            offset<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">,</span>
            is_const<span class="token operator">:</span> false
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">"dy"</span><span class="token punctuation">,</span>
    type<span class="token operator">:</span> TYPE_FLOAT<span class="token punctuation">,</span>
    scope<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    info<span class="token operator">:</span> <span class="token punctuation">{</span>
        var_info<span class="token operator">:</span> <span class="token punctuation">{</span>
            offset<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span>
            is_const<span class="token operator">:</span> false
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>对应的常量表是这样的：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 常量表</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    type<span class="token operator">:</span> CONST_INT<span class="token punctuation">,</span>
    value<span class="token operator">:</span> <span class="token punctuation">{</span>
        int_val<span class="token operator">:</span> <span class="token number">100</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    is_used<span class="token operator">:</span> true<span class="token punctuation">,</span>
    ref_count<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    type<span class="token operator">:</span> CONST_INT<span class="token punctuation">,</span>
    value<span class="token operator">:</span> <span class="token punctuation">{</span>
        int_val<span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    is_used<span class="token operator">:</span> true<span class="token punctuation">,</span>
    ref_count<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    type<span class="token operator">:</span> CONST_STRING<span class="token punctuation">,</span>
    value<span class="token operator">:</span> <span class="token punctuation">{</span>
        string_info<span class="token operator">:</span> <span class="token punctuation">{</span>
            str_val<span class="token operator">:</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">,</span>
            length<span class="token operator">:</span> <span class="token number">13</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    is_used<span class="token operator">:</span> true<span class="token punctuation">,</span>
    ref_count<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre><p>这些表的使用特点：</p>
<ol>
<li>
<p>作用域管理：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 局部作用域</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-int">int</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 内层作用域</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>符号表需要正确处理这种嵌套作用域，通常用链表或栈实现。</p>
</li>
<li>
<p>查找效率：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">SymbolTable</span> <span class="token punctuation">{</span>
    SymbolEntry <span class="token operator">*</span>entries<span class="token punctuation">;</span>     <span class="token comment">// 数组存储</span>
    <span class="token keyword keyword-int">int</span> size<span class="token punctuation">;</span>
    HashTable <span class="token operator">*</span>quick_lookup<span class="token punctuation">;</span>  <span class="token comment">// 哈希表加速查找</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></li>
<li>
<p>类型检查：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-float">float</span> f <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> f<span class="token punctuation">;</span>  <span class="token comment">// 需要检查类型兼容性</span>
</code></pre><p>符号表提供类型信息支持语义分析。</p>
</li>
<li>
<p>内存分配：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">Point</span> p<span class="token punctuation">;</span>  <span class="token comment">// 需要知道Point结构体的大小</span>
</code></pre><p>符号表记录的类型信息帮助确定内存布局。</p>
</li>
<li>
<p>常量折叠：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-int">int</span> A <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-int">int</span> B <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> c <span class="token operator">=</span> A <span class="token operator">+</span> B<span class="token punctuation">;</span>  <span class="token comment">// 可以在编译时计算</span>
</code></pre><p>常量表支持编译期优化。</p>
</li>
</ol>
<p>符号表和常量表是编译器的核心数据结构，它们：</p>
<ul>
<li>支持作用域管理</li>
<li>提供类型检查信息</li>
<li>辅助代码生成</li>
<li>支持编译优化</li>
<li>协助错误检查和报告</li>
</ul>
<p>因此它们的设计需要在存储效率、查找速度和功能完备性之间取得平衡。</p>
<hr>
<p>让我详细说明符号表和常量表的组织方式。</p>
<p>符号表的组织通常有几种方式：</p>
<p><strong>1. 哈希表（最常用）：</strong><br>
首先是基本的数据结构定义：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 符号表项</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">SymbolEntry</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>                    <span class="token comment">// 符号名</span>
    <span class="token keyword keyword-int">int</span> type<span class="token punctuation">;</span>                     <span class="token comment">// 符号类型</span>
    <span class="token comment">// ... 其他属性</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">SymbolEntry</span> <span class="token operator">*</span>hash_next<span class="token punctuation">;</span>  <span class="token comment">// 同一哈希桶中的下一个符号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 哈希桶</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">HashBucket</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">SymbolEntry</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>  <span class="token comment">// 桶的第一个符号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 单个作用域的符号表</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">ScopeTable</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">HashBucket</span> buckets<span class="token punctuation">[</span>HASH_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 当前作用域的哈希表</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">ScopeTable</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>               <span class="token comment">// 外层作用域</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 整个符号表</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">SymbolTable</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">ScopeTable</span> <span class="token operator">*</span>current_scope<span class="token punctuation">;</span>  <span class="token comment">// 当前作用域</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>让我们通过一个例子来看这些结构是如何工作的：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> global <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-float">float</span> y <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>这段代码会形成三层嵌套的作用域，每个作用域都有自己的哈希表：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>全局作用域的哈希表：
[0] → null
[1] → SymbolEntry("global") → null
[2] → null
[3] → SymbolEntry("foo") → null
[4] → null
...

foo函数作用域的哈希表：
[0] → null
[1] → null
[2] → SymbolEntry("x") → null
[3] → null
[4] → null
...

if块作用域的哈希表：
[0] → null
[1] → SymbolEntry("y") → null
[2] → SymbolEntry("msg") → null
[3] → null
[4] → null
...
</code></pre><p>这些作用域通过<code>ScopeTable</code>的<code>prev</code>指针连接成一个链：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>if块作用域 → foo函数作用域 → 全局作用域 → null
</code></pre><p>在实际使用中，符号表的操作主要包括：</p>
<ol>
<li>
<p>进入新作用域：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">enter_scope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建新的作用域</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">ScopeTable</span> <span class="token operator">*</span>new_scope <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">ScopeTable</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 初始化哈希桶</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> HASH_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        new_scope<span class="token operator">-&gt;</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 链接到当前作用域</span>
    new_scope<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> symtab<span class="token punctuation">.</span>current_scope<span class="token punctuation">;</span>
    <span class="token comment">// 更新当前作用域</span>
    symtab<span class="token punctuation">.</span>current_scope <span class="token operator">=</span> new_scope<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li>
<li>
<p>添加新符号：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">insert_symbol</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 计算哈希值</span>
    <span class="token keyword keyword-int">int</span> hash <span class="token operator">=</span> <span class="token function">hash_function</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 创建新符号</span>
    SymbolEntry <span class="token operator">*</span>entry <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>SymbolEntry<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    entry<span class="token operator">-&gt;</span>name <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    entry<span class="token operator">-&gt;</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>
    
    <span class="token comment">// 插入到当前作用域的哈希表中</span>
    entry<span class="token operator">-&gt;</span>hash_next <span class="token operator">=</span> symtab<span class="token punctuation">.</span>current_scope<span class="token operator">-&gt;</span>buckets<span class="token punctuation">[</span>hash<span class="token punctuation">]</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    symtab<span class="token punctuation">.</span>current_scope<span class="token operator">-&gt;</span>buckets<span class="token punctuation">[</span>hash<span class="token punctuation">]</span><span class="token punctuation">.</span>head <span class="token operator">=</span> entry<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li>
<li>
<p>查找符号：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>SymbolEntry<span class="token operator">*</span> <span class="token function">lookup_symbol</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 计算哈希值</span>
    <span class="token keyword keyword-int">int</span> hash <span class="token operator">=</span> <span class="token function">hash_function</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 从当前作用域开始查找</span>
    ScopeTable <span class="token operator">*</span>scope <span class="token operator">=</span> symtab<span class="token punctuation">.</span>current_scope<span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>scope <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在当前作用域的哈希表中查找</span>
        SymbolEntry <span class="token operator">*</span>entry <span class="token operator">=</span> scope<span class="token operator">-&gt;</span>buckets<span class="token punctuation">[</span>hash<span class="token punctuation">]</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
        <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>entry <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>entry<span class="token operator">-&gt;</span>name<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword keyword-return">return</span> entry<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            entry <span class="token operator">=</span> entry<span class="token operator">-&gt;</span>hash_next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 找不到就去外层作用域找</span>
        scope <span class="token operator">=</span> scope<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li>
<li>
<p>退出作用域：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">exit_scope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 保存当前作用域</span>
    ScopeTable <span class="token operator">*</span>old_scope <span class="token operator">=</span> symtab<span class="token punctuation">.</span>current_scope<span class="token punctuation">;</span>
    <span class="token comment">// 返回到外层作用域</span>
    symtab<span class="token punctuation">.</span>current_scope <span class="token operator">=</span> old_scope<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span>
    <span class="token comment">// 释放当前作用域的所有符号和哈希表</span>
    <span class="token function">free_scope</span><span class="token punctuation">(</span>old_scope<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li>
</ol>
<p>这种实现方式的优点是：</p>
<ol>
<li>查找效率高：使用哈希表可以快速定位符号</li>
<li>作用域管理清晰：每个作用域有独立的哈希表</li>
<li>变量遮蔽处理自然：在当前作用域找到同名变量就直接返回</li>
<li>内存管理方便：退出作用域时可以直接释放整个作用域的内存</li>
</ol>
<p>如果在同一个作用域中出现哈希冲突（多个符号的哈希值相同），这些符号会通过<code>hash_next</code>指针连接在同一个哈希桶中形成链表。比如：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> abc <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> xyz <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 假设abc和xyz的哈希值都是2</span>
<span class="token punctuation">}</span>
</code></pre><p>会形成这样的结构：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>当前作用域的哈希表：
[0] → null
[1] → null
[2] → SymbolEntry("abc") → SymbolEntry("xyz") → null
[3] → null
...
</code></pre><p>这就是符号表使用哈希表实现的完整结构和工作方式。这种实现既保证了符号查找的效率，又很好地支持了作用域的嵌套和变量遮蔽。</p>
<p><strong>2. 二叉搜索树：</strong></p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">SymbolTable</span> <span class="token punctuation">{</span>
    <span class="token comment">// 每个作用域一棵BST</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">ScopeNode</span> <span class="token punctuation">{</span>
        SymbolEntry <span class="token operator">*</span>root<span class="token punctuation">;</span>    <span class="token comment">// BST根节点</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">ScopeNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token operator">*</span>current_scope<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-struct">struct</span> <span class="token class-name">SymbolEntry</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> type<span class="token punctuation">;</span>
    <span class="token comment">// ... 其他属性</span>
    
    <span class="token comment">// BST指针</span>
    SymbolEntry <span class="token operator">*</span>left<span class="token punctuation">;</span>
    SymbolEntry <span class="token operator">*</span>right<span class="token punctuation">;</span>
    <span class="token comment">// 同作用域链表</span>
    SymbolEntry <span class="token operator">*</span>scope_next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>常量表的组织比较简单，通常用以下方式：</p>
<p><strong>1. 数组（简单常量）：</strong></p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">ConstTable</span> <span class="token punctuation">{</span>
    ConstEntry <span class="token operator">*</span>entries<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> size<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> capacity<span class="token punctuation">;</span>
    
    <span class="token comment">// 哈希表用于快速查找重复常量</span>
    HashTable <span class="token operator">*</span>lookup<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p><strong>2. 分类存储（不同类型分开存储）：</strong></p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">ConstTable</span> <span class="token punctuation">{</span>
    <span class="token comment">// 数值常量用数组</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-int">int</span> <span class="token operator">*</span>values<span class="token punctuation">;</span>
        <span class="token keyword keyword-int">int</span> size<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> int_consts<span class="token punctuation">;</span>
    
    <span class="token keyword keyword-struct">struct</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-float">float</span> <span class="token operator">*</span>values<span class="token punctuation">;</span>
        <span class="token keyword keyword-int">int</span> size<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> float_consts<span class="token punctuation">;</span>
    
    <span class="token comment">// 字符串常量用哈希表</span>
    StringPool <span class="token operator">*</span>string_consts<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>对于上面的示例代码，其常量表可能是这样的：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">ConstTable</span> consttab <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>int_consts <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>values <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">3</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>float_consts <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>values <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3.14</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>string_consts <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token string">"hello"</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>分类存储的方式有几个明显的优点：</p>
<ol>
<li>类型安全：不同类型的常量分开存储，避免类型混淆</li>
<li>存储效率：每种类型可以选择最适合的存储方式
<ul>
<li>数值常量用定长数组存储，访问高效</li>
<li>字符串常量用哈希表存储，方便去重</li>
</ul>
</li>
<li>查找方便：根据常量类型直接定位到对应的存储区域</li>
<li>空间利用率高：相同的常量只存储一次，特别是对字符串这样的大型常量很有帮助</li>
</ol>
<p>这样的常量表设计配合前面的符号表，能够有效支持编译器的词法分析和语义分析工作。符号表负责管理标识符及其作用域，而常量表则专注于管理程序中的各类常量值，两者各司其职，共同构成了编译器的重要数据管理基础设施。</p>
<hr>
<p>对，这就是所谓的保留字表（Reserved Word Table）和特殊符号表（Special Symbol Table）。让我详细解释一下：</p>
<ol>
<li>
<p>保留字表（存放关键字）：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">KeywordEntry</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>lexeme<span class="token punctuation">;</span>      <span class="token comment">// 关键字字符串</span>
    <span class="token keyword keyword-int">int</span> token_type<span class="token punctuation">;</span>    <span class="token comment">// 对应的词法单元类型</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 静态定义的关键字表</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-const">const</span> KeywordEntry keywords<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span><span class="token string">"if"</span><span class="token punctuation">,</span>      TOK_IF<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"else"</span><span class="token punctuation">,</span>    TOK_ELSE<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"while"</span><span class="token punctuation">,</span>   TOK_WHILE<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"for"</span><span class="token punctuation">,</span>     TOK_FOR<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"int"</span><span class="token punctuation">,</span>     TOK_INT<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"float"</span><span class="token punctuation">,</span>   TOK_FLOAT<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"return"</span><span class="token punctuation">,</span>  TOK_RETURN<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"struct"</span><span class="token punctuation">,</span>  TOK_STRUCT<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"void"</span><span class="token punctuation">,</span>    TOK_VOID<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// ... 其他关键字</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></li>
<li>
<p>特殊符号表（存放运算符和分隔符）：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">OperatorEntry</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>lexeme<span class="token punctuation">;</span>      <span class="token comment">// 符号字符串</span>
    <span class="token keyword keyword-int">int</span> token_type<span class="token punctuation">;</span>    <span class="token comment">// 对应的词法单元类型</span>
    <span class="token keyword keyword-int">int</span> precedence<span class="token punctuation">;</span>    <span class="token comment">// 优先级（用于表达式分析）</span>
    bool is_binary<span class="token punctuation">;</span>    <span class="token comment">// 是否是双目运算符</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-const">const</span> OperatorEntry operators<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span><span class="token string">"+"</span><span class="token punctuation">,</span>   TOK_PLUS<span class="token punctuation">,</span>    <span class="token number">10</span><span class="token punctuation">,</span> true<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"-"</span><span class="token punctuation">,</span>   TOK_MINUS<span class="token punctuation">,</span>   <span class="token number">10</span><span class="token punctuation">,</span> true<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"*"</span><span class="token punctuation">,</span>   TOK_MULT<span class="token punctuation">,</span>    <span class="token number">20</span><span class="token punctuation">,</span> true<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"/"</span><span class="token punctuation">,</span>   TOK_DIV<span class="token punctuation">,</span>     <span class="token number">20</span><span class="token punctuation">,</span> true<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"++"</span><span class="token punctuation">,</span>  TOK_INC<span class="token punctuation">,</span>     <span class="token number">30</span><span class="token punctuation">,</span> false<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"--"</span><span class="token punctuation">,</span>  TOK_DEC<span class="token punctuation">,</span>     <span class="token number">30</span><span class="token punctuation">,</span> false<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"=="</span><span class="token punctuation">,</span>  TOK_EQ<span class="token punctuation">,</span>      <span class="token number">5</span><span class="token punctuation">,</span>  true<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"!="</span><span class="token punctuation">,</span>  TOK_NE<span class="token punctuation">,</span>      <span class="token number">5</span><span class="token punctuation">,</span>  true<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"="</span><span class="token punctuation">,</span>   TOK_ASSIGN<span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  true<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// ... 其他运算符</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-struct">struct</span> <span class="token class-name">DelimiterEntry</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> lexeme<span class="token punctuation">;</span>       <span class="token comment">// 分隔符字符</span>
    <span class="token keyword keyword-int">int</span> token_type<span class="token punctuation">;</span>    <span class="token comment">// 对应的词法单元类型</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-const">const</span> DelimiterEntry delimiters<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span><span class="token char">'('</span><span class="token punctuation">,</span>  TOK_LPAREN<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token char">')'</span><span class="token punctuation">,</span>  TOK_RPAREN<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token char">'{'</span><span class="token punctuation">,</span>  TOK_LBRACE<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token char">'}'</span><span class="token punctuation">,</span>  TOK_RBRACE<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token char">'['</span><span class="token punctuation">,</span>  TOK_LBRACKET<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token char">']'</span><span class="token punctuation">,</span>  TOK_RBRACKET<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token char">';'</span><span class="token punctuation">,</span>  TOK_SEMI<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token char">','</span><span class="token punctuation">,</span>  TOK_COMMA<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token char">'.'</span><span class="token punctuation">,</span>  TOK_DOT<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// ... 其他分隔符</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></li>
</ol>
<p>在词法分析器中使用这些表的例子：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 检查是否是关键字</span>
<span class="token keyword keyword-int">int</span> <span class="token function">check_keyword</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>keywords<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>keywords<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> keywords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lexeme<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-return">return</span> keywords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>token_type<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> TOK_ID<span class="token punctuation">;</span>  <span class="token comment">// 不是关键字就是标识符</span>
<span class="token punctuation">}</span>

<span class="token comment">// 检查是否是运算符</span>
<span class="token keyword keyword-int">int</span> <span class="token function">check_operator</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>operators<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>operators<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> operators<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lexeme<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-return">return</span> operators<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>token_type<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 不是合法运算符</span>
<span class="token punctuation">}</span>

<span class="token comment">// 检查是否是分隔符</span>
<span class="token keyword keyword-int">int</span> <span class="token function">check_delimiter</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>delimiters<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>delimiters<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> delimiters<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lexeme<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-return">return</span> delimiters<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>token_type<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 不是合法分隔符</span>
<span class="token punctuation">}</span>
</code></pre><p>实际使用例子：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">tokenize</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> buffer<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 用于暂存字符</span>
    <span class="token keyword keyword-int">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">isspace</span><span class="token punctuation">(</span><span class="token operator">*</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            input<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// 检查分隔符</span>
        <span class="token keyword keyword-int">int</span> delim_type <span class="token operator">=</span> <span class="token function">check_delimiter</span><span class="token punctuation">(</span><span class="token operator">*</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>delim_type <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"分隔符: %c (类型: %d)\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>input<span class="token punctuation">,</span> delim_type<span class="token punctuation">)</span><span class="token punctuation">;</span>
            input<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// 收集可能的标识符或关键字</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">isalpha</span><span class="token punctuation">(</span><span class="token operator">*</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token function">isalnum</span><span class="token punctuation">(</span><span class="token operator">*</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                buffer<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span>input<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            buffer<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
            
            <span class="token comment">// 检查是否是关键字</span>
            <span class="token keyword keyword-int">int</span> type <span class="token operator">=</span> <span class="token function">check_keyword</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>type <span class="token operator">!=</span> TOK_ID<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"关键字: %s (类型: %d)\n"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"标识符: %s\n"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// 收集可能的运算符</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">ispunct</span><span class="token punctuation">(</span><span class="token operator">*</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            buffer<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span>input<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token comment">// 处理可能的双字符运算符</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">ispunct</span><span class="token punctuation">(</span><span class="token operator">*</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                buffer<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span>input<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            buffer<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
            
            <span class="token keyword keyword-int">int</span> op_type <span class="token operator">=</span> <span class="token function">check_operator</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>op_type <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"运算符: %s (类型: %d)\n"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> op_type<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>pos <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 回退一个字符，可能是单字符运算符</span>
                input<span class="token operator">--</span><span class="token punctuation">;</span>
                buffer<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
                op_type <span class="token operator">=</span> <span class="token function">check_operator</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>op_type <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"运算符: %s (类型: %d)\n"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> op_type<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        input<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">// 跳过未识别的字符</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>这些表的好处是：</p>
<ol>
<li>
<p>快速识别：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>  <span class="token comment">// 需要快速确定int是关键字而不是标识符</span>
</code></pre></li>
<li>
<p>运算符优先级：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>a <span class="token operator">+</span> b <span class="token operator">*</span> c  <span class="token comment">// 需要知道*的优先级高于+</span>
</code></pre><p>通过运算符表记录的优先级信息可以支持表达式分析。</p>
</li>
<li>
<p>错误检查：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>x @ y<span class="token punctuation">)</span>  <span class="token comment">// @不是合法运算符</span>
</code></pre><p>可以快速发现非法符号。</p>
</li>
<li>
<p>支持多字符运算符：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>x<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 需要正确识别++而不是两个+</span>
x <span class="token operator">+=</span> y<span class="token punctuation">;</span> <span class="token comment">// 需要正确识别+=而不是+和=</span>
</code></pre></li>
<li>
<p>编译器扩展：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 添加新关键字很容易</span>
<span class="token punctuation">{</span><span class="token string">"foreach"</span><span class="token punctuation">,</span> TOK_FOREACH<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token comment">// 添加新运算符也很方便</span>
<span class="token punctuation">{</span><span class="token string">"**"</span><span class="token punctuation">,</span> TOK_POWER<span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> true<span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 幂运算</span>
</code></pre></li>
</ol>
<p>这些表通常会被优化成更高效的形式：</p>
<ol>
<li>
<p>哈希表：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">KeywordTable</span> <span class="token punctuation">{</span>
    HashTable <span class="token operator">*</span>lookup<span class="token punctuation">;</span>  <span class="token comment">// 快速查找关键字</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></li>
<li>
<p>状态转移表：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 用于处理多字符运算符</span>
<span class="token keyword keyword-int">int</span> state_table<span class="token punctuation">[</span>STATE_COUNT<span class="token punctuation">]</span><span class="token punctuation">[</span>CHAR_COUNT<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></li>
<li>
<p>静态完美哈希：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 编译时生成的完美哈希函数</span>
<span class="token keyword keyword-int">int</span> <span class="token function">keyword_hash</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 为关键字生成唯一的索引</span>
<span class="token punctuation">}</span>
</code></pre></li>
</ol>
<p>这样的设计让词法分析器能够高效且准确地识别所有的语言元素。</p>
<hr>
<p>我来用DOT语言绘制词法分析程序的完整流程图：</p>
<p class="dot"><!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<!-- Generated by graphviz version 9.0.0 (20230911.1827)
 -->
<!-- Title: lexical_analysis Pages: 1 -->
<svg width="1468pt" height="897pt" viewBox="0.00 0.00 1468.00 896.80" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 892.8)">
<title>lexical_analysis</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-892.8 1464,-892.8 1464,4 -4,4"></polygon>
<!-- start -->
<g id="node1" class="node">
<title>start</title>
<ellipse fill="none" stroke="black" cx="922" cy="-870.8" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="922" y="-866.6" font-family="Times,serif" font-size="14.00">开始</text>
</g>
<!-- init -->
<g id="node3" class="node">
<title>init</title>
<path fill="none" stroke="black" d="M954.75,-815.8C954.75,-815.8 889.25,-815.8 889.25,-815.8 883.25,-815.8 877.25,-809.8 877.25,-803.8 877.25,-803.8 877.25,-786.2 877.25,-786.2 877.25,-780.2 883.25,-774.2 889.25,-774.2 889.25,-774.2 954.75,-774.2 954.75,-774.2 960.75,-774.2 966.75,-780.2 966.75,-786.2 966.75,-786.2 966.75,-803.8 966.75,-803.8 966.75,-809.8 960.75,-815.8 954.75,-815.8"></path>
<text text-anchor="middle" x="922" y="-799.2" font-family="Times,serif" font-size="14.00">初始化</text>
<text text-anchor="middle" x="922" y="-782.4" font-family="Times,serif" font-size="14.00">词法分析器状态</text>
</g>
<!-- start&#45;&gt;init -->
<g id="edge1" class="edge">
<title>start-&gt;init</title>
<path fill="none" stroke="black" d="M922,-852.31C922,-844.95 922,-836.15 922,-827.72"></path>
<polygon fill="black" stroke="black" points="925.5,-827.75 922,-817.75 918.5,-827.75 925.5,-827.75"></polygon>
</g>
<!-- end -->
<g id="node2" class="node">
<title>end</title>
<ellipse fill="none" stroke="black" cx="93" cy="-486.6" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="93" y="-482.4" font-family="Times,serif" font-size="14.00">结束</text>
</g>
<!-- read -->
<g id="node4" class="node">
<title>read</title>
<path fill="none" stroke="black" d="M954.75,-737.2C954.75,-737.2 889.25,-737.2 889.25,-737.2 883.25,-737.2 877.25,-731.2 877.25,-725.2 877.25,-725.2 877.25,-713.2 877.25,-713.2 877.25,-707.2 883.25,-701.2 889.25,-701.2 889.25,-701.2 954.75,-701.2 954.75,-701.2 960.75,-701.2 966.75,-707.2 966.75,-713.2 966.75,-713.2 966.75,-725.2 966.75,-725.2 966.75,-731.2 960.75,-737.2 954.75,-737.2"></path>
<text text-anchor="middle" x="922" y="-715" font-family="Times,serif" font-size="14.00">读取下一个字符</text>
</g>
<!-- init&#45;&gt;read -->
<g id="edge2" class="edge">
<title>init-&gt;read</title>
<path fill="none" stroke="black" d="M922,-773.83C922,-766.06 922,-757.03 922,-748.62"></path>
<polygon fill="black" stroke="black" points="925.5,-748.85 922,-738.85 918.5,-748.85 925.5,-748.85"></polygon>
</g>
<!-- check_eof -->
<g id="node28" class="node">
<title>check_eof</title>
<path fill="none" stroke="black" d="M191.93,-657.68C191.93,-657.68 147.86,-629.12 147.86,-629.12 142.82,-625.86 142.82,-619.34 147.86,-616.08 147.86,-616.08 191.93,-587.52 191.93,-587.52 196.96,-584.26 207.04,-584.26 212.07,-587.52 212.07,-587.52 256.14,-616.08 256.14,-616.08 261.18,-619.34 261.18,-625.86 256.14,-629.12 256.14,-629.12 212.07,-657.68 212.07,-657.68 207.04,-660.94 196.96,-660.94 191.93,-657.68"></path>
<text text-anchor="middle" x="202" y="-626.8" font-family="Times,serif" font-size="14.00">是否到达</text>
<text text-anchor="middle" x="202" y="-610" font-family="Times,serif" font-size="14.00">文件末尾?</text>
</g>
<!-- read&#45;&gt;check_eof -->
<g id="edge3" class="edge">
<title>read-&gt;check_eof</title>
<path fill="none" stroke="black" d="M877.02,-717.01C794.39,-714.32 613.05,-706.13 462,-683.2 390.55,-672.36 309.6,-652.59 257.28,-638.8"></path>
<polygon fill="black" stroke="black" points="258.26,-635.44 247.7,-636.26 256.47,-642.21 258.26,-635.44"></polygon>
</g>
<!-- check_space -->
<g id="node5" class="node">
<title>check_space</title>
<path fill="none" stroke="black" d="M191.93,-521.68C191.93,-521.68 147.86,-493.12 147.86,-493.12 142.82,-489.86 142.82,-483.34 147.86,-480.08 147.86,-480.08 191.93,-451.52 191.93,-451.52 196.96,-448.26 207.04,-448.26 212.07,-451.52 212.07,-451.52 256.14,-480.08 256.14,-480.08 261.18,-483.34 261.18,-489.86 256.14,-493.12 256.14,-493.12 212.07,-521.68 212.07,-521.68 207.04,-524.94 196.96,-524.94 191.93,-521.68"></path>
<text text-anchor="middle" x="202" y="-490.8" font-family="Times,serif" font-size="14.00">是否为</text>
<text text-anchor="middle" x="202" y="-474" font-family="Times,serif" font-size="14.00">空白字符?</text>
</g>
<!-- skip_space -->
<g id="node6" class="node">
<title>skip_space</title>
<path fill="none" stroke="black" d="M130.5,-368.6C130.5,-368.6 75.5,-368.6 75.5,-368.6 69.5,-368.6 63.5,-362.6 63.5,-356.6 63.5,-356.6 63.5,-344.6 63.5,-344.6 63.5,-338.6 69.5,-332.6 75.5,-332.6 75.5,-332.6 130.5,-332.6 130.5,-332.6 136.5,-332.6 142.5,-338.6 142.5,-344.6 142.5,-344.6 142.5,-356.6 142.5,-356.6 142.5,-362.6 136.5,-368.6 130.5,-368.6"></path>
<text text-anchor="middle" x="103" y="-346.4" font-family="Times,serif" font-size="14.00">跳过空白字符</text>
</g>
<!-- check_space&#45;&gt;skip_space -->
<g id="edge6" class="edge">
<title>check_space-&gt;skip_space</title>
<path fill="none" stroke="black" d="M181.49,-457.84C164.14,-434.36 139.47,-400.96 122.43,-377.91"></path>
<polygon fill="black" stroke="black" points="125.3,-375.9 116.55,-369.94 119.67,-380.06 125.3,-375.9"></polygon>
<text text-anchor="middle" x="164.25" y="-414.4" font-family="Times,serif" font-size="14.00">是</text>
</g>
<!-- check_letter -->
<g id="node7" class="node">
<title>check_letter</title>
<path fill="none" stroke="black" d="M363.35,-501.72C363.35,-501.72 313.77,-489.48 313.77,-489.48 307.94,-488.04 307.94,-485.16 313.77,-483.72 313.77,-483.72 363.35,-471.48 363.35,-471.48 369.18,-470.04 380.82,-470.04 386.65,-471.48 386.65,-471.48 436.23,-483.72 436.23,-483.72 442.06,-485.16 442.06,-488.04 436.23,-489.48 436.23,-489.48 386.65,-501.72 386.65,-501.72 380.82,-503.16 369.18,-503.16 363.35,-501.72"></path>
<text text-anchor="middle" x="375" y="-482.4" font-family="Times,serif" font-size="14.00">是否为字母?</text>
</g>
<!-- check_space&#45;&gt;check_letter -->
<g id="edge8" class="edge">
<title>check_space-&gt;check_letter</title>
<path fill="none" stroke="black" d="M266.91,-486.6C274.02,-486.6 281.34,-486.6 288.66,-486.6"></path>
<polygon fill="black" stroke="black" points="288.61,-490.1 298.61,-486.6 288.61,-483.1 288.61,-490.1"></polygon>
<text text-anchor="middle" x="284.17" y="-493.8" font-family="Times,serif" font-size="14.00">否</text>
</g>
<!-- skip_space&#45;&gt;read -->
<g id="edge7" class="edge">
<title>skip_space-&gt;read</title>
<path fill="none" stroke="black" d="M91.42,-368.93C80.09,-387.02 63.6,-416.66 57,-445 33.74,-544.87 43,-608.35 129,-664.2 190.34,-704.04 694.01,-714.93 865.26,-717.49"></path>
<polygon fill="black" stroke="black" points="865.2,-720.99 875.25,-717.64 865.3,-713.99 865.2,-720.99"></polygon>
</g>
<!-- read_id -->
<g id="node8" class="node">
<title>read_id</title>
<path fill="none" stroke="black" d="M397.25,-368.6C397.25,-368.6 352.75,-368.6 352.75,-368.6 346.75,-368.6 340.75,-362.6 340.75,-356.6 340.75,-356.6 340.75,-344.6 340.75,-344.6 340.75,-338.6 346.75,-332.6 352.75,-332.6 352.75,-332.6 397.25,-332.6 397.25,-332.6 403.25,-332.6 409.25,-338.6 409.25,-344.6 409.25,-344.6 409.25,-356.6 409.25,-356.6 409.25,-362.6 403.25,-368.6 397.25,-368.6"></path>
<text text-anchor="middle" x="375" y="-346.4" font-family="Times,serif" font-size="14.00">读取标识符</text>
</g>
<!-- check_letter&#45;&gt;read_id -->
<g id="edge9" class="edge">
<title>check_letter-&gt;read_id</title>
<path fill="none" stroke="black" d="M375,-468.36C375,-446.04 375,-406.87 375,-380.1"></path>
<polygon fill="black" stroke="black" points="378.5,-380.29 375,-370.29 371.5,-380.29 378.5,-380.29"></polygon>
<text text-anchor="middle" x="380.25" y="-414.4" font-family="Times,serif" font-size="14.00">是</text>
</g>
<!-- check_digit -->
<g id="node12" class="node">
<title>check_digit</title>
<path fill="none" stroke="black" d="M603.35,-501.72C603.35,-501.72 553.77,-489.48 553.77,-489.48 547.94,-488.04 547.94,-485.16 553.77,-483.72 553.77,-483.72 603.35,-471.48 603.35,-471.48 609.18,-470.04 620.82,-470.04 626.65,-471.48 626.65,-471.48 676.23,-483.72 676.23,-483.72 682.06,-485.16 682.06,-488.04 676.23,-489.48 676.23,-489.48 626.65,-501.72 626.65,-501.72 620.82,-503.16 609.18,-503.16 603.35,-501.72"></path>
<text text-anchor="middle" x="615" y="-482.4" font-family="Times,serif" font-size="14.00">是否为数字?</text>
</g>
<!-- check_letter&#45;&gt;check_digit -->
<g id="edge15" class="edge">
<title>check_letter-&gt;check_digit</title>
<path fill="none" stroke="black" d="M449.95,-486.6C474.99,-486.6 503.09,-486.6 528.91,-486.6"></path>
<polygon fill="black" stroke="black" points="528.69,-490.1 538.69,-486.6 528.69,-483.1 528.69,-490.1"></polygon>
<text text-anchor="middle" x="495" y="-493.8" font-family="Times,serif" font-size="14.00">否</text>
</g>
<!-- check_keyword -->
<g id="node9" class="node">
<title>check_keyword</title>
<path fill="none" stroke="black" d="M365.51,-248.85C365.51,-248.85 330.77,-221.95 330.77,-221.95 326.03,-218.27 326.03,-210.93 330.77,-207.25 330.77,-207.25 365.51,-180.35 365.51,-180.35 370.26,-176.67 379.74,-176.67 384.49,-180.35 384.49,-180.35 419.23,-207.25 419.23,-207.25 423.97,-210.93 423.97,-218.27 419.23,-221.95 419.23,-221.95 384.49,-248.85 384.49,-248.85 379.74,-252.53 370.26,-252.53 365.51,-248.85"></path>
<text text-anchor="middle" x="375" y="-218.8" font-family="Times,serif" font-size="14.00">是否为</text>
<text text-anchor="middle" x="375" y="-202" font-family="Times,serif" font-size="14.00">关键字?</text>
</g>
<!-- read_id&#45;&gt;check_keyword -->
<g id="edge10" class="edge">
<title>read_id-&gt;check_keyword</title>
<path fill="none" stroke="black" d="M375,-332.36C375,-316.09 375,-290.86 375,-268.01"></path>
<polygon fill="black" stroke="black" points="378.5,-268.2 375,-258.2 371.5,-268.2 378.5,-268.2"></polygon>
</g>
<!-- gen_keyword -->
<g id="node10" class="node">
<title>gen_keyword</title>
<path fill="none" stroke="black" d="M447.25,-120.2C447.25,-120.2 402.75,-120.2 402.75,-120.2 396.75,-120.2 390.75,-114.2 390.75,-108.2 390.75,-108.2 390.75,-90.6 390.75,-90.6 390.75,-84.6 396.75,-78.6 402.75,-78.6 402.75,-78.6 447.25,-78.6 447.25,-78.6 453.25,-78.6 459.25,-84.6 459.25,-90.6 459.25,-90.6 459.25,-108.2 459.25,-108.2 459.25,-114.2 453.25,-120.2 447.25,-120.2"></path>
<text text-anchor="middle" x="425" y="-103.6" font-family="Times,serif" font-size="14.00">生成关键字</text>
<text text-anchor="middle" x="425" y="-86.8" font-family="Times,serif" font-size="14.00">词法单元</text>
</g>
<!-- check_keyword&#45;&gt;gen_keyword -->
<g id="edge11" class="edge">
<title>check_keyword-&gt;gen_keyword</title>
<path fill="none" stroke="black" d="M388.53,-182.97C395.63,-166.9 404.3,-147.27 411.4,-131.18"></path>
<polygon fill="black" stroke="black" points="414.58,-132.64 415.42,-122.08 408.18,-129.81 414.58,-132.64"></polygon>
<text text-anchor="middle" x="413.25" y="-142.4" font-family="Times,serif" font-size="14.00">是</text>
</g>
<!-- gen_id -->
<g id="node11" class="node">
<title>gen_id</title>
<path fill="none" stroke="black" d="M199.25,-120.2C199.25,-120.2 154.75,-120.2 154.75,-120.2 148.75,-120.2 142.75,-114.2 142.75,-108.2 142.75,-108.2 142.75,-90.6 142.75,-90.6 142.75,-84.6 148.75,-78.6 154.75,-78.6 154.75,-78.6 199.25,-78.6 199.25,-78.6 205.25,-78.6 211.25,-84.6 211.25,-90.6 211.25,-90.6 211.25,-108.2 211.25,-108.2 211.25,-114.2 205.25,-120.2 199.25,-120.2"></path>
<text text-anchor="middle" x="177" y="-103.6" font-family="Times,serif" font-size="14.00">生成标识符</text>
<text text-anchor="middle" x="177" y="-86.8" font-family="Times,serif" font-size="14.00">词法单元</text>
</g>
<!-- check_keyword&#45;&gt;gen_id -->
<g id="edge12" class="edge">
<title>check_keyword-&gt;gen_id</title>
<path fill="none" stroke="black" d="M344.5,-196.16C311.54,-177.32 258.71,-147.11 221.2,-125.67"></path>
<polygon fill="black" stroke="black" points="223.27,-122.82 212.85,-120.9 219.79,-128.9 223.27,-122.82"></polygon>
<text text-anchor="middle" x="276.25" y="-142.4" font-family="Times,serif" font-size="14.00">否</text>
</g>
<!-- gen_keyword&#45;&gt;read -->
<g id="edge13" class="edge">
<title>gen_keyword-&gt;read</title>
<path fill="none" stroke="black" d="M440.3,-120.45C455.32,-142.18 476,-178.46 476,-213.6 476,-623.6 476,-623.6 476,-623.6 476,-702.31 745.17,-715.82 865.29,-717.93"></path>
<polygon fill="black" stroke="black" points="865.22,-721.43 875.27,-718.08 865.32,-714.43 865.22,-721.43"></polygon>
</g>
<!-- gen_id&#45;&gt;read -->
<g id="edge14" class="edge">
<title>gen_id-&gt;read</title>
<path fill="none" stroke="black" d="M142.45,-106.39C90.94,-117.53 0,-146.67 0,-213.6 0,-623.6 0,-623.6 0,-623.6 0,-714.22 104.74,-675.05 195,-683.2 444.32,-705.72 743.14,-714.35 865.53,-717.1"></path>
<polygon fill="black" stroke="black" points="865.23,-720.59 875.31,-717.31 865.38,-713.59 865.23,-720.59"></polygon>
</g>
<!-- read_number -->
<g id="node13" class="node">
<title>read_number</title>
<path fill="none" stroke="black" d="M609,-368.6C609,-368.6 575,-368.6 575,-368.6 569,-368.6 563,-362.6 563,-356.6 563,-356.6 563,-344.6 563,-344.6 563,-338.6 569,-332.6 575,-332.6 575,-332.6 609,-332.6 609,-332.6 615,-332.6 621,-338.6 621,-344.6 621,-344.6 621,-356.6 621,-356.6 621,-362.6 615,-368.6 609,-368.6"></path>
<text text-anchor="middle" x="592" y="-346.4" font-family="Times,serif" font-size="14.00">读取数字</text>
</g>
<!-- check_digit&#45;&gt;read_number -->
<g id="edge16" class="edge">
<title>check_digit-&gt;read_number</title>
<path fill="none" stroke="black" d="M612.13,-468.9C608.32,-446.65 601.5,-406.97 596.87,-379.99"></path>
<polygon fill="black" stroke="black" points="600.37,-379.69 595.23,-370.43 593.47,-380.88 600.37,-379.69"></polygon>
<text text-anchor="middle" x="610.25" y="-414.4" font-family="Times,serif" font-size="14.00">是</text>
</g>
<!-- check_operator -->
<g id="node18" class="node">
<title>check_operator</title>
<path fill="none" stroke="black" d="M798.22,-522.94C798.22,-522.94 734.57,-491.86 734.57,-491.86 729.18,-489.23 729.18,-483.97 734.57,-481.34 734.57,-481.34 798.22,-450.26 798.22,-450.26 803.61,-447.63 814.39,-447.63 819.78,-450.26 819.78,-450.26 883.43,-481.34 883.43,-481.34 888.82,-483.97 888.82,-489.23 883.43,-491.86 883.43,-491.86 819.78,-522.94 819.78,-522.94 814.39,-525.57 803.61,-525.57 798.22,-522.94"></path>
<text text-anchor="middle" x="809" y="-490.8" font-family="Times,serif" font-size="14.00">是否为</text>
<text text-anchor="middle" x="809" y="-474" font-family="Times,serif" font-size="14.00">可能的运算符?</text>
</g>
<!-- check_digit&#45;&gt;check_operator -->
<g id="edge23" class="edge">
<title>check_digit-&gt;check_operator</title>
<path fill="none" stroke="black" d="M689.73,-486.6C696.8,-486.6 704.04,-486.6 711.29,-486.6"></path>
<polygon fill="black" stroke="black" points="711.15,-490.1 721.15,-486.6 711.15,-483.1 711.15,-490.1"></polygon>
<text text-anchor="middle" x="705.83" y="-493.8" font-family="Times,serif" font-size="14.00">否</text>
</g>
<!-- check_float -->
<g id="node14" class="node">
<title>check_float</title>
<path fill="none" stroke="black" d="M619.27,-230.06C619.27,-230.06 559.6,-217.14 559.6,-217.14 553.74,-215.87 553.74,-213.33 559.6,-212.06 559.6,-212.06 619.27,-199.14 619.27,-199.14 625.14,-197.87 636.86,-197.87 642.73,-199.14 642.73,-199.14 702.4,-212.06 702.4,-212.06 708.26,-213.33 708.26,-215.87 702.4,-217.14 702.4,-217.14 642.73,-230.06 642.73,-230.06 636.86,-231.33 625.14,-231.33 619.27,-230.06"></path>
<text text-anchor="middle" x="631" y="-210.4" font-family="Times,serif" font-size="14.00">是否有小数点?</text>
</g>
<!-- read_number&#45;&gt;check_float -->
<g id="edge17" class="edge">
<title>read_number-&gt;check_float</title>
<path fill="none" stroke="black" d="M597.02,-332.36C603.61,-309.7 615.27,-269.64 623.07,-242.86"></path>
<polygon fill="black" stroke="black" points="626.39,-243.97 625.82,-233.39 619.67,-242.02 626.39,-243.97"></polygon>
</g>
<!-- read_decimal -->
<g id="node15" class="node">
<title>read_decimal</title>
<path fill="none" stroke="black" d="M762.5,-117.4C762.5,-117.4 707.5,-117.4 707.5,-117.4 701.5,-117.4 695.5,-111.4 695.5,-105.4 695.5,-105.4 695.5,-93.4 695.5,-93.4 695.5,-87.4 701.5,-81.4 707.5,-81.4 707.5,-81.4 762.5,-81.4 762.5,-81.4 768.5,-81.4 774.5,-87.4 774.5,-93.4 774.5,-93.4 774.5,-105.4 774.5,-105.4 774.5,-111.4 768.5,-117.4 762.5,-117.4"></path>
<text text-anchor="middle" x="735" y="-95.2" font-family="Times,serif" font-size="14.00">读取小数部分</text>
</g>
<!-- check_float&#45;&gt;read_decimal -->
<g id="edge18" class="edge">
<title>check_float-&gt;read_decimal</title>
<path fill="none" stroke="black" d="M644.17,-199.26C661.06,-180.88 690.64,-148.68 711.45,-126.03"></path>
<polygon fill="black" stroke="black" points="714.01,-128.42 718.2,-118.69 708.85,-123.69 714.01,-128.42"></polygon>
<text text-anchor="middle" x="704.25" y="-142.4" font-family="Times,serif" font-size="14.00">是</text>
</g>
<!-- gen_int -->
<g id="node16" class="node">
<title>gen_int</title>
<path fill="none" stroke="black" d="M1046,-120.2C1046,-120.2 1012,-120.2 1012,-120.2 1006,-120.2 1000,-114.2 1000,-108.2 1000,-108.2 1000,-90.6 1000,-90.6 1000,-84.6 1006,-78.6 1012,-78.6 1012,-78.6 1046,-78.6 1046,-78.6 1052,-78.6 1058,-84.6 1058,-90.6 1058,-90.6 1058,-108.2 1058,-108.2 1058,-114.2 1052,-120.2 1046,-120.2"></path>
<text text-anchor="middle" x="1029" y="-103.6" font-family="Times,serif" font-size="14.00">生成整数</text>
<text text-anchor="middle" x="1029" y="-86.8" font-family="Times,serif" font-size="14.00">词法单元</text>
</g>
<!-- check_float&#45;&gt;gen_int -->
<g id="edge20" class="edge">
<title>check_float-&gt;gen_int</title>
<path fill="none" stroke="black" d="M655.12,-201.5C673.4,-192.69 699.34,-180.95 723,-173 816.16,-141.69 929.59,-118.52 988.74,-107.52"></path>
<polygon fill="black" stroke="black" points="989.13,-111 998.33,-105.75 987.86,-104.12 989.13,-111"></polygon>
<text text-anchor="middle" x="845.25" y="-142.4" font-family="Times,serif" font-size="14.00">否</text>
</g>
<!-- gen_float -->
<g id="node17" class="node">
<title>gen_float</title>
<path fill="none" stroke="black" d="M1274.25,-41.6C1274.25,-41.6 1229.75,-41.6 1229.75,-41.6 1223.75,-41.6 1217.75,-35.6 1217.75,-29.6 1217.75,-29.6 1217.75,-12 1217.75,-12 1217.75,-6 1223.75,0 1229.75,0 1229.75,0 1274.25,0 1274.25,0 1280.25,0 1286.25,-6 1286.25,-12 1286.25,-12 1286.25,-29.6 1286.25,-29.6 1286.25,-35.6 1280.25,-41.6 1274.25,-41.6"></path>
<text text-anchor="middle" x="1252" y="-25" font-family="Times,serif" font-size="14.00">生成浮点数</text>
<text text-anchor="middle" x="1252" y="-8.2" font-family="Times,serif" font-size="14.00">词法单元</text>
</g>
<!-- read_decimal&#45;&gt;gen_float -->
<g id="edge19" class="edge">
<title>read_decimal-&gt;gen_float</title>
<path fill="none" stroke="black" d="M774.71,-92.52C868.99,-78.55 1105.87,-43.45 1206.09,-28.6"></path>
<polygon fill="black" stroke="black" points="1206.45,-32.09 1215.83,-27.16 1205.43,-25.16 1206.45,-32.09"></polygon>
</g>
<!-- gen_int&#45;&gt;read -->
<g id="edge22" class="edge">
<title>gen_int-&gt;read</title>
<path fill="none" stroke="black" d="M1041.94,-120.39C1079.81,-181.38 1185.25,-370.5 1145,-528.2 1127.6,-596.37 1118.16,-619.3 1064,-664.2 1039.35,-684.64 1006.15,-697.83 978.05,-706.06"></path>
<polygon fill="black" stroke="black" points="977.32,-702.63 968.62,-708.68 979.19,-709.38 977.32,-702.63"></polygon>
</g>
<!-- gen_float&#45;&gt;read -->
<g id="edge21" class="edge">
<title>gen_float-&gt;read</title>
<path fill="none" stroke="black" d="M1286.35,-27.16C1345.42,-37.36 1460,-61.84 1460,-98.4 1460,-623.6 1460,-623.6 1460,-623.6 1460,-658.04 1426.44,-652.63 1394,-664.2 1318.67,-691.08 1086.6,-708.22 978.5,-714.96"></path>
<polygon fill="black" stroke="black" points="978.46,-711.45 968.7,-715.56 978.89,-718.44 978.46,-711.45"></polygon>
</g>
<!-- check_second -->
<g id="node19" class="node">
<title>check_second</title>
<path fill="none" stroke="black" d="M765.7,-388.17C765.7,-388.17 671.59,-354.63 671.59,-354.63 665.94,-352.61 665.94,-348.59 671.59,-346.57 671.59,-346.57 765.7,-313.03 765.7,-313.03 771.35,-311.01 782.65,-311.01 788.3,-313.03 788.3,-313.03 882.41,-346.57 882.41,-346.57 888.06,-348.59 888.06,-352.61 882.41,-354.63 882.41,-354.63 788.3,-388.17 788.3,-388.17 782.65,-390.19 771.35,-390.19 765.7,-388.17"></path>
<text text-anchor="middle" x="777" y="-354.8" font-family="Times,serif" font-size="14.00">检查下一个字符</text>
<text text-anchor="middle" x="777" y="-338" font-family="Times,serif" font-size="14.00">是否组成复合运算符?</text>
</g>
<!-- check_operator&#45;&gt;check_second -->
<g id="edge24" class="edge">
<title>check_operator-&gt;check_second</title>
<path fill="none" stroke="black" d="M800.26,-448.98C796.65,-433.87 792.41,-416.15 788.56,-399.99"></path>
<polygon fill="black" stroke="black" points="792.03,-399.49 786.31,-390.58 785.23,-401.12 792.03,-399.49"></polygon>
<text text-anchor="middle" x="800.25" y="-414.4" font-family="Times,serif" font-size="14.00">是</text>
</g>
<!-- check_delimiter -->
<g id="node22" class="node">
<title>check_delimiter</title>
<path fill="none" stroke="black" d="M1021.27,-502.06C1021.27,-502.06 961.6,-489.14 961.6,-489.14 955.74,-487.87 955.74,-485.33 961.6,-484.06 961.6,-484.06 1021.27,-471.14 1021.27,-471.14 1027.14,-469.87 1038.86,-469.87 1044.73,-471.14 1044.73,-471.14 1104.4,-484.06 1104.4,-484.06 1110.26,-485.33 1110.26,-487.87 1104.4,-489.14 1104.4,-489.14 1044.73,-502.06 1044.73,-502.06 1038.86,-503.33 1027.14,-503.33 1021.27,-502.06"></path>
<text text-anchor="middle" x="1033" y="-482.4" font-family="Times,serif" font-size="14.00">是否为分隔符?</text>
</g>
<!-- check_operator&#45;&gt;check_delimiter -->
<g id="edge29" class="edge">
<title>check_operator-&gt;check_delimiter</title>
<path fill="none" stroke="black" d="M895.28,-486.6C908.76,-486.6 922.77,-486.6 936.46,-486.6"></path>
<polygon fill="black" stroke="black" points="936.35,-490.1 946.35,-486.6 936.35,-483.1 936.35,-490.1"></polygon>
<text text-anchor="middle" x="922.04" y="-493.8" font-family="Times,serif" font-size="14.00">否</text>
</g>
<!-- gen_compound_op -->
<g id="node20" class="node">
<title>gen_compound_op</title>
<path fill="none" stroke="black" d="M809.75,-235.4C809.75,-235.4 744.25,-235.4 744.25,-235.4 738.25,-235.4 732.25,-229.4 732.25,-223.4 732.25,-223.4 732.25,-205.8 732.25,-205.8 732.25,-199.8 738.25,-193.8 744.25,-193.8 744.25,-193.8 809.75,-193.8 809.75,-193.8 815.75,-193.8 821.75,-199.8 821.75,-205.8 821.75,-205.8 821.75,-223.4 821.75,-223.4 821.75,-229.4 815.75,-235.4 809.75,-235.4"></path>
<text text-anchor="middle" x="777" y="-218.8" font-family="Times,serif" font-size="14.00">生成复合运算符</text>
<text text-anchor="middle" x="777" y="-202" font-family="Times,serif" font-size="14.00">词法单元</text>
</g>
<!-- check_second&#45;&gt;gen_compound_op -->
<g id="edge25" class="edge">
<title>check_second-&gt;gen_compound_op</title>
<path fill="none" stroke="black" d="M777,-308.67C777,-288.84 777,-265.41 777,-247.02"></path>
<polygon fill="black" stroke="black" points="780.5,-247.26 777,-237.26 773.5,-247.26 780.5,-247.26"></polygon>
<text text-anchor="middle" x="782.25" y="-278.4" font-family="Times,serif" font-size="14.00">是</text>
</g>
<!-- gen_single_op -->
<g id="node21" class="node">
<title>gen_single_op</title>
<path fill="none" stroke="black" d="M944,-235.4C944,-235.4 868,-235.4 868,-235.4 862,-235.4 856,-229.4 856,-223.4 856,-223.4 856,-205.8 856,-205.8 856,-199.8 862,-193.8 868,-193.8 868,-193.8 944,-193.8 944,-193.8 950,-193.8 956,-199.8 956,-205.8 956,-205.8 956,-223.4 956,-223.4 956,-229.4 950,-235.4 944,-235.4"></path>
<text text-anchor="middle" x="906" y="-218.8" font-family="Times,serif" font-size="14.00">生成单字符运算符</text>
<text text-anchor="middle" x="906" y="-202" font-family="Times,serif" font-size="14.00">词法单元</text>
</g>
<!-- check_second&#45;&gt;gen_single_op -->
<g id="edge26" class="edge">
<title>check_second-&gt;gen_single_op</title>
<path fill="none" stroke="black" d="M806.27,-319.19C828.16,-296.46 857.84,-265.62 879.13,-243.51"></path>
<polygon fill="black" stroke="black" points="881.38,-246.22 885.79,-236.59 876.33,-241.37 881.38,-246.22"></polygon>
<text text-anchor="middle" x="855.25" y="-278.4" font-family="Times,serif" font-size="14.00">否</text>
</g>
<!-- gen_compound_op&#45;&gt;read -->
<g id="edge27" class="edge">
<title>gen_compound_op-&gt;read</title>
<path fill="none" stroke="black" d="M753.71,-235.87C744.59,-243.04 733.75,-250.69 723,-256.2 652.98,-292.1 605.33,-249.35 554,-309 549.34,-314.42 509.84,-491.11 533,-528.2 606.61,-646.07 776.81,-692.79 865.68,-709.65"></path>
<polygon fill="black" stroke="black" points="864.92,-713.07 875.39,-711.43 866.18,-706.18 864.92,-713.07"></polygon>
</g>
<!-- gen_single_op&#45;&gt;read -->
<g id="edge28" class="edge">
<title>gen_single_op-&gt;read</title>
<path fill="none" stroke="black" d="M909.87,-235.49C914.61,-261.58 922,-308.83 922,-349.6 922,-623.6 922,-623.6 922,-623.6 922,-645.69 922,-670.69 922,-689.44"></path>
<polygon fill="black" stroke="black" points="918.5,-689.25 922,-699.25 925.5,-689.25 918.5,-689.25"></polygon>
</g>
<!-- gen_delimiter -->
<g id="node23" class="node">
<title>gen_delimiter</title>
<path fill="none" stroke="black" d="M1074.25,-371.4C1074.25,-371.4 1029.75,-371.4 1029.75,-371.4 1023.75,-371.4 1017.75,-365.4 1017.75,-359.4 1017.75,-359.4 1017.75,-341.8 1017.75,-341.8 1017.75,-335.8 1023.75,-329.8 1029.75,-329.8 1029.75,-329.8 1074.25,-329.8 1074.25,-329.8 1080.25,-329.8 1086.25,-335.8 1086.25,-341.8 1086.25,-341.8 1086.25,-359.4 1086.25,-359.4 1086.25,-365.4 1080.25,-371.4 1074.25,-371.4"></path>
<text text-anchor="middle" x="1052" y="-354.8" font-family="Times,serif" font-size="14.00">生成分隔符</text>
<text text-anchor="middle" x="1052" y="-338" font-family="Times,serif" font-size="14.00">词法单元</text>
</g>
<!-- check_delimiter&#45;&gt;gen_delimiter -->
<g id="edge30" class="edge">
<title>check_delimiter-&gt;gen_delimiter</title>
<path fill="none" stroke="black" d="M1035.41,-468.63C1038.47,-447.03 1043.81,-409.33 1047.61,-382.56"></path>
<polygon fill="black" stroke="black" points="1051.03,-383.37 1048.97,-372.98 1044.1,-382.39 1051.03,-383.37"></polygon>
<text text-anchor="middle" x="1049.25" y="-414.4" font-family="Times,serif" font-size="14.00">是</text>
</g>
<!-- check_quote -->
<g id="node24" class="node">
<title>check_quote</title>
<path fill="none" stroke="black" d="M1309.35,-501.72C1309.35,-501.72 1259.77,-489.48 1259.77,-489.48 1253.94,-488.04 1253.94,-485.16 1259.77,-483.72 1259.77,-483.72 1309.35,-471.48 1309.35,-471.48 1315.18,-470.04 1326.82,-470.04 1332.65,-471.48 1332.65,-471.48 1382.23,-483.72 1382.23,-483.72 1388.06,-485.16 1388.06,-488.04 1382.23,-489.48 1382.23,-489.48 1332.65,-501.72 1332.65,-501.72 1326.82,-503.16 1315.18,-503.16 1309.35,-501.72"></path>
<text text-anchor="middle" x="1321" y="-482.4" font-family="Times,serif" font-size="14.00">是否为引号?</text>
</g>
<!-- check_delimiter&#45;&gt;check_quote -->
<g id="edge32" class="edge">
<title>check_delimiter-&gt;check_quote</title>
<path fill="none" stroke="black" d="M1118.24,-486.6C1155.07,-486.6 1198.09,-486.6 1235,-486.6"></path>
<polygon fill="black" stroke="black" points="1234.73,-490.1 1244.73,-486.6 1234.73,-483.1 1234.73,-490.1"></polygon>
<text text-anchor="middle" x="1182.12" y="-493.8" font-family="Times,serif" font-size="14.00">否</text>
</g>
<!-- gen_delimiter&#45;&gt;read -->
<g id="edge31" class="edge">
<title>gen_delimiter-&gt;read</title>
<path fill="none" stroke="black" d="M1074.36,-371.72C1091.92,-389.12 1115.01,-416.01 1125,-445 1137.04,-479.96 1139.71,-494.28 1125,-528.2 1091.94,-604.43 1011.55,-664.05 962.43,-694.93"></path>
<polygon fill="black" stroke="black" points="960.72,-691.88 954.04,-700.11 964.39,-697.84 960.72,-691.88"></polygon>
</g>
<!-- read_string -->
<g id="node25" class="node">
<title>read_string</title>
<path fill="none" stroke="black" d="M1381.75,-368.6C1381.75,-368.6 1316.25,-368.6 1316.25,-368.6 1310.25,-368.6 1304.25,-362.6 1304.25,-356.6 1304.25,-356.6 1304.25,-344.6 1304.25,-344.6 1304.25,-338.6 1310.25,-332.6 1316.25,-332.6 1316.25,-332.6 1381.75,-332.6 1381.75,-332.6 1387.75,-332.6 1393.75,-338.6 1393.75,-344.6 1393.75,-344.6 1393.75,-356.6 1393.75,-356.6 1393.75,-362.6 1387.75,-368.6 1381.75,-368.6"></path>
<text text-anchor="middle" x="1349" y="-346.4" font-family="Times,serif" font-size="14.00">读取字符串内容</text>
</g>
<!-- check_quote&#45;&gt;read_string -->
<g id="edge33" class="edge">
<title>check_quote-&gt;read_string</title>
<path fill="none" stroke="black" d="M1324.43,-469.17C1329.06,-447.01 1337.38,-407.21 1343.04,-380.11"></path>
<polygon fill="black" stroke="black" points="1346.43,-381 1345.05,-370.5 1339.58,-379.57 1346.43,-381"></polygon>
<text text-anchor="middle" x="1341.25" y="-414.4" font-family="Times,serif" font-size="14.00">是</text>
</g>
<!-- error -->
<g id="node27" class="node">
<title>error</title>
<path fill="none" stroke="black" d="M1275.51,-356.56C1275.51,-356.56 1264.88,-362.64 1264.88,-362.64 1259.67,-365.62 1248.46,-368.6 1242.46,-368.6 1242.46,-368.6 1203.54,-368.6 1203.54,-368.6 1197.54,-368.6 1186.33,-365.62 1181.12,-362.64 1181.12,-362.64 1170.49,-356.56 1170.49,-356.56 1165.29,-353.58 1165.29,-347.62 1170.49,-344.64 1170.49,-344.64 1181.12,-338.56 1181.12,-338.56 1186.33,-335.58 1197.54,-332.6 1203.54,-332.6 1203.54,-332.6 1242.46,-332.6 1242.46,-332.6 1248.46,-332.6 1259.67,-335.58 1264.88,-338.56 1264.88,-338.56 1275.51,-344.64 1275.51,-344.64 1280.71,-347.62 1280.71,-353.58 1275.51,-356.56"></path>
<text text-anchor="middle" x="1223" y="-346.4" font-family="Times,serif" font-size="14.00">词法错误处理</text>
</g>
<!-- check_quote&#45;&gt;error -->
<g id="edge36" class="edge">
<title>check_quote-&gt;error</title>
<path fill="none" stroke="black" d="M1310.33,-471C1294,-448.68 1262.57,-405.7 1242.2,-377.86"></path>
<polygon fill="black" stroke="black" points="1245.13,-375.93 1236.4,-369.92 1239.48,-380.06 1245.13,-375.93"></polygon>
<text text-anchor="middle" x="1282.25" y="-414.4" font-family="Times,serif" font-size="14.00">否</text>
</g>
<!-- gen_string -->
<g id="node26" class="node">
<title>gen_string</title>
<path fill="none" stroke="black" d="M1395.25,-235.4C1395.25,-235.4 1350.75,-235.4 1350.75,-235.4 1344.75,-235.4 1338.75,-229.4 1338.75,-223.4 1338.75,-223.4 1338.75,-205.8 1338.75,-205.8 1338.75,-199.8 1344.75,-193.8 1350.75,-193.8 1350.75,-193.8 1395.25,-193.8 1395.25,-193.8 1401.25,-193.8 1407.25,-199.8 1407.25,-205.8 1407.25,-205.8 1407.25,-223.4 1407.25,-223.4 1407.25,-229.4 1401.25,-235.4 1395.25,-235.4"></path>
<text text-anchor="middle" x="1373" y="-218.8" font-family="Times,serif" font-size="14.00">生成字符串</text>
<text text-anchor="middle" x="1373" y="-202" font-family="Times,serif" font-size="14.00">词法单元</text>
</g>
<!-- read_string&#45;&gt;gen_string -->
<g id="edge34" class="edge">
<title>read_string-&gt;gen_string</title>
<path fill="none" stroke="black" d="M1352.09,-332.36C1355.95,-310.81 1362.63,-273.52 1367.4,-246.88"></path>
<polygon fill="black" stroke="black" points="1370.79,-247.79 1369.11,-237.33 1363.9,-246.56 1370.79,-247.79"></polygon>
</g>
<!-- gen_string&#45;&gt;read -->
<g id="edge35" class="edge">
<title>gen_string-&gt;read</title>
<path fill="none" stroke="black" d="M1385.36,-235.65C1399.88,-261.15 1422,-306.99 1422,-349.6 1422,-623.6 1422,-623.6 1422,-623.6 1422,-668.35 1108.73,-701.53 978.12,-713.42"></path>
<polygon fill="black" stroke="black" points="977.97,-709.92 968.32,-714.3 978.59,-716.89 977.97,-709.92"></polygon>
</g>
<!-- error&#45;&gt;read -->
<g id="edge37" class="edge">
<title>error-&gt;read</title>
<path fill="none" stroke="black" d="M1224.3,-368.76C1228.54,-430.18 1239.39,-637.78 1196,-683.2 1167.05,-713.5 1049.93,-718.74 978.51,-719.02"></path>
<polygon fill="black" stroke="black" points="978.54,-715.52 968.54,-719.02 978.55,-722.52 978.54,-715.52"></polygon>
</g>
<!-- check_eof&#45;&gt;end -->
<g id="edge4" class="edge">
<title>check_eof-&gt;end</title>
<path fill="none" stroke="black" d="M180.2,-594.81C160.44,-570.5 131.56,-535.01 112.53,-511.61"></path>
<polygon fill="black" stroke="black" points="115.26,-509.42 106.23,-503.87 109.83,-513.83 115.26,-509.42"></polygon>
<text text-anchor="middle" x="160.25" y="-550.4" font-family="Times,serif" font-size="14.00">是</text>
</g>
<!-- check_eof&#45;&gt;check_space -->
<g id="edge5" class="edge">
<title>check_eof-&gt;check_space</title>
<path fill="none" stroke="black" d="M202,-580.67C202,-567.8 202,-553.41 202,-539.87"></path>
<polygon fill="black" stroke="black" points="205.5,-540.26 202,-530.26 198.5,-540.26 205.5,-540.26"></polygon>
<text text-anchor="middle" x="207.25" y="-550.4" font-family="Times,serif" font-size="14.00">否</text>
</g>
</g>
</svg>
</p><p>这个流程图展示了词法分析器的主要处理流程：</p>
<ol>
<li>
<p>初始化阶段：</p>
<ul>
<li>设置初始状态</li>
<li>准备输入缓冲区</li>
<li>初始化各种表（关键字表、运算符表等）</li>
</ul>
</li>
<li>
<p>主处理循环：</p>
<ul>
<li>读取输入字符</li>
<li>根据字符类型进行分支处理</li>
<li>生成对应的词法单元</li>
</ul>
</li>
<li>
<p>各种类型的处理：</p>
<ul>
<li>空白字符：直接跳过</li>
<li>标识符/关键字：收集字母数字序列，查表判断</li>
<li>数字：处理整数和浮点数</li>
<li>运算符：处理单字符和多字符运算符</li>
<li>分隔符：直接生成对应词法单元</li>
<li>字符串：处理引号内的内容</li>
</ul>
</li>
<li>
<p>错误处理：</p>
<ul>
<li>遇到非法字符时进行错误处理</li>
<li>可以继续扫描后续输入</li>
</ul>
</li>
<li>
<p>结束处理：</p>
<ul>
<li>检测文件结束</li>
<li>完成最后的清理工作</li>
</ul>
</li>
</ol>
<p>这个流程图涵盖了词法分析的主要功能，同时也展示了各个处理环节之间的关系。实际实现时可能会根据具体语言的要求添加更多的处理分支和细节。</p>
<hr>
<p>词法分析器的预处理过程主要处理输入的原始文本，让它变得更容易被词法分析器处理。我来详细讲解这个过程。</p>
<p>预处理主要做这些工作：</p>
<ol>
<li>
<p>缓冲区管理</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">Buffer</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-char">char</span> data<span class="token punctuation">[</span>BUFFER_SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 双倍大小的缓冲区</span>
  <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span>   <span class="token comment">// 向前指针</span>
  <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>lexemeBegin<span class="token punctuation">;</span>  <span class="token comment">// 词素起始指针</span>
  <span class="token keyword keyword-int">int</span> currentBlock<span class="token punctuation">;</span>   <span class="token comment">// 当前正在读的块（0或1）</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></li>
<li>
<p>双缓冲技术<br>
将输入缓冲区分为两个相等大小的块：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>+----------------+----------------+
|     块 0       |      块 1      |
+----------------+----------------+
</code></pre><p>工作原理：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">loadBuffer</span><span class="token punctuation">(</span>Buffer <span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>buf<span class="token operator">-&gt;</span>currentBlock <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当扫描到块0末尾时，加载块1</span>
    <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token operator">-&gt;</span>data <span class="token operator">+</span> BUFFER_SIZE<span class="token punctuation">,</span> BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    buf<span class="token operator">-&gt;</span>currentBlock <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当扫描到块1末尾时，加载块0</span>
    <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token operator">-&gt;</span>data<span class="token punctuation">,</span> BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    buf<span class="token operator">-&gt;</span>currentBlock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></li>
<li>
<p>预处理操作</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">preprocess</span><span class="token punctuation">(</span>Buffer <span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1. 移除注释</span>
  <span class="token function">removeComments</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 2. 处理转义字符</span>
  <span class="token function">handleEscapeSequences</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 3. 合并空白字符</span>
  <span class="token function">mergeWhitespace</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 4. 处理宏展开（如果支持）</span>
  <span class="token function">expandMacros</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li>
</ol>
<p>让我用一个具体例子来说明这个过程：</p>
<p>假设有这样的源代码：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 这是一个注释 */</span>
    <span class="token keyword keyword-int">int</span>  count    <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 变量初始化</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出</span>
<span class="token punctuation">}</span>
</code></pre><p>预处理的各个步骤：</p>
<ol>
<li>
<p>移除注释：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
    <span class="token keyword keyword-int">int</span>  count    <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
</code></pre></li>
<li>
<p>规范化空白字符：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li>
</ol>
<p>实现预处理器的代码示例：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">PreProcessor</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> buffer<span class="token punctuation">[</span>BUFFER_SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> currentPos<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> bufferEnd<span class="token punctuation">;</span>
    FILE <span class="token operator">*</span>sourceFile<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">initPreProcessor</span><span class="token punctuation">(</span>PreProcessor <span class="token operator">*</span>pp<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>filename<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pp<span class="token operator">-&gt;</span>sourceFile <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pp<span class="token operator">-&gt;</span>currentPos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    pp<span class="token operator">-&gt;</span>bufferEnd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-char">char</span> <span class="token function">getNextChar</span><span class="token punctuation">(</span>PreProcessor <span class="token operator">*</span>pp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果当前位置到达缓冲区末尾，需要重新加载</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>pp<span class="token operator">-&gt;</span>currentPos <span class="token operator">&gt;=</span> pp<span class="token operator">-&gt;</span>bufferEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pp<span class="token operator">-&gt;</span>bufferEnd <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>pp<span class="token operator">-&gt;</span>buffer<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> BUFFER_SIZE<span class="token punctuation">,</span> pp<span class="token operator">-&gt;</span>sourceFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pp<span class="token operator">-&gt;</span>currentPos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>pp<span class="token operator">-&gt;</span>bufferEnd <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span> <span class="token constant">EOF</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> pp<span class="token operator">-&gt;</span>buffer<span class="token punctuation">[</span>pp<span class="token operator">-&gt;</span>currentPos<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">skipComment</span><span class="token punctuation">(</span>PreProcessor <span class="token operator">*</span>pp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> c <span class="token operator">=</span> <span class="token function">getNextChar</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 单行注释</span>
        <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token function">getNextChar</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span> <span class="token operator">&amp;&amp;</span> c <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 多行注释</span>
        <span class="token keyword keyword-char">char</span> prev <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token function">getNextChar</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> <span class="token char">'*'</span> <span class="token operator">&amp;&amp;</span> c <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span> <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
            prev <span class="token operator">=</span> c<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>预处理器需要处理一些特殊情况：</p>
<ol>
<li>
<p>文件结束处理：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EOF_MARKER</span> <span class="token char">'\0'</span></span>

<span class="token keyword keyword-void">void</span> <span class="token function">markBufferEnd</span><span class="token punctuation">(</span>Buffer <span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 在每个块的末尾放置EOF标记</span>
  buf<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>BUFFER_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> EOF_MARKER<span class="token punctuation">;</span>
  buf<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>BUFFER_SIZE <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> EOF_MARKER<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li>
<li>
<p>行号和列号跟踪：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">Position</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-int">int</span> line<span class="token punctuation">;</span>
  <span class="token keyword keyword-int">int</span> column<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">updatePosition</span><span class="token punctuation">(</span>Position <span class="token operator">*</span>pos<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pos<span class="token operator">-&gt;</span>line<span class="token operator">++</span><span class="token punctuation">;</span>
    pos<span class="token operator">-&gt;</span>column <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
    pos<span class="token operator">-&gt;</span>column<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></li>
<li>
<p>错误处理：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">handleError</span><span class="token punctuation">(</span>PreProcessor <span class="token operator">*</span>pp<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Error at line %d, column %d: %s\n"</span><span class="token punctuation">,</span>
          pp<span class="token operator">-&gt;</span>position<span class="token punctuation">.</span>line<span class="token punctuation">,</span> pp<span class="token operator">-&gt;</span>position<span class="token punctuation">.</span>column<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li>
</ol>
<p>预处理的好处是：</p>
<ol>
<li>
<p>简化词法分析器的工作：</p>
<ul>
<li>不需要处理注释</li>
<li>不需要处理连续空白字符</li>
<li>行号和列号信息已经准备好</li>
</ul>
</li>
<li>
<p>提高效率：</p>
<ul>
<li>使用双缓冲减少I/O操作</li>
<li>提前处理一些特殊情况</li>
</ul>
</li>
<li>
<p>便于错误处理：</p>
<ul>
<li>准确的行号和列号信息</li>
<li>统一的错误处理机制</li>
</ul>
</li>
</ol>
<p>预处理完成后，词法分析器就可以直接在处理过的文本上工作，专注于识别词法单元，而不必关心这些底层细节。</p>
<hr>
<p>双缓冲技术是词法分析器中一个很巧妙的设计。我来详细解释它的工作原理。</p>
<p>双缓冲的基本思想是：把输入缓冲区分成大小相等的两个缓冲区，在扫描一个缓冲区的内容时，可以同时读入内容到另一个缓冲区中。</p>
<p>基本结构：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">Buffer</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> data<span class="token punctuation">[</span>BUFFER_SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 两倍大小的缓冲区</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span>               <span class="token comment">// 向前指针，指向当前正在读取的字符</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>lexemeBegin<span class="token punctuation">;</span>          <span class="token comment">// 词素起始指针，指向当前词素的开始位置</span>
    bool loading<span class="token punctuation">;</span>               <span class="token comment">// 是否正在加载新的缓冲区</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>缓冲区的结构示意图：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>+----------------+----------------+
|    缓冲区1     |    缓冲区2     |
+----------------+----------------+
 ↑            ↑  ↑
 lexemeBegin  |  |
          forward|
                EOF
</code></pre><ol>
<li>
<p>初始化阶段：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">initBuffer</span><span class="token punctuation">(</span>Buffer <span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 先读满第一个缓冲区</span>
  <span class="token function">readBlock</span><span class="token punctuation">(</span>buf<span class="token operator">-&gt;</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 在第一个缓冲区末尾放置EOF标记</span>
  buf<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>BUFFER_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">EOF</span><span class="token punctuation">;</span>
  <span class="token comment">// 初始化指针</span>
  buf<span class="token operator">-&gt;</span>forward <span class="token operator">=</span> buf<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
  buf<span class="token operator">-&gt;</span>lexemeBegin <span class="token operator">=</span> buf<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li>
<li>
<p>向前扫描过程：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-char">char</span><span class="token operator">*</span> <span class="token function">forward</span><span class="token punctuation">(</span>Buffer <span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 检查是否到达EOF标记</span>
  <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token operator">-&gt;</span>forward <span class="token operator">==</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果在第一个缓冲区末尾</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>buf<span class="token operator">-&gt;</span>forward <span class="token operator">==</span> buf<span class="token operator">-&gt;</span>data <span class="token operator">+</span> BUFFER_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 检查词素长度</span>
      <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>buf<span class="token operator">-&gt;</span>forward <span class="token operator">-</span> buf<span class="token operator">-&gt;</span>lexemeBegin <span class="token operator">&gt;=</span> BUFFER_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Lexeme too long"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 加载第二个缓冲区</span>
      <span class="token function">readBlock</span><span class="token punctuation">(</span>buf<span class="token operator">-&gt;</span>data <span class="token operator">+</span> BUFFER_SIZE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 在第二个缓冲区末尾放置EOF标记</span>
      buf<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>BUFFER_SIZE <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">EOF</span><span class="token punctuation">;</span>
      <span class="token comment">// 移动到第二个缓冲区开始</span>
      buf<span class="token operator">-&gt;</span>forward <span class="token operator">=</span> buf<span class="token operator">-&gt;</span>data <span class="token operator">+</span> BUFFER_SIZE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果在第二个缓冲区末尾</span>
    <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>buf<span class="token operator">-&gt;</span>forward <span class="token operator">==</span> buf<span class="token operator">-&gt;</span>data <span class="token operator">+</span> BUFFER_SIZE <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 检查词素长度</span>
      <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>buf<span class="token operator">-&gt;</span>lexemeBegin <span class="token operator">&lt;</span> buf<span class="token operator">-&gt;</span>data <span class="token operator">+</span> BUFFER_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Lexeme too long"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 加载第一个缓冲区</span>
      <span class="token function">readBlock</span><span class="token punctuation">(</span>buf<span class="token operator">-&gt;</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 在第一个缓冲区末尾放置EOF标记</span>
      buf<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>BUFFER_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">EOF</span><span class="token punctuation">;</span>
      <span class="token comment">// 移动到第一个缓冲区开始</span>
      buf<span class="token operator">-&gt;</span>forward <span class="token operator">=</span> buf<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword keyword-return">return</span> buf<span class="token operator">-&gt;</span>forward<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li>
<li>
<p>词素识别过程：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">skipWhitespace</span><span class="token punctuation">(</span>Buffer <span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token function">isspace</span><span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token operator">-&gt;</span>forward<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">forward</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  buf<span class="token operator">-&gt;</span>lexemeBegin <span class="token operator">=</span> buf<span class="token operator">-&gt;</span>forward<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">scanToken</span><span class="token punctuation">(</span>Buffer <span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 跳过空白字符</span>
  <span class="token function">skipWhitespace</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 读取词素的字符直到满足特定条件</span>
  <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token comment">/* 词素未结束条件 */</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">forward</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 获取词素内容</span>
  <span class="token keyword keyword-int">int</span> length <span class="token operator">=</span> buf<span class="token operator">-&gt;</span>forward <span class="token operator">-</span> buf<span class="token operator">-&gt;</span>lexemeBegin<span class="token punctuation">;</span>
  <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>lexeme <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">memcpy</span><span class="token punctuation">(</span>lexeme<span class="token punctuation">,</span> buf<span class="token operator">-&gt;</span>lexemeBegin<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
  lexeme<span class="token punctuation">[</span>length<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 识别完一个词素后更新lexemeBegin</span>
  buf<span class="token operator">-&gt;</span>lexemeBegin <span class="token operator">=</span> buf<span class="token operator">-&gt;</span>forward<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li>
</ol>
<p>一个重要的限制是：词素的长度必须不大于单个缓冲区的大小（<code>BUFFER_SIZE</code>）。这是因为如果词素长度超过<code>BUFFER_SIZE</code>，在需要重新加载缓冲区时可能会丢失数据。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 假设BUFFER_SIZE = 8</span>
缓冲区<span class="token number">1</span>：<span class="token operator">|</span>abcdefgh<span class="token operator">|</span>  <span class="token comment">// 词素在a开始</span>
缓冲区<span class="token number">2</span>：<span class="token operator">|</span>ijklmnop<span class="token operator">|</span>  <span class="token comment">// 词素延续到p</span>

<span class="token comment">// 如果词素还没结束，需要继续读取</span>
缓冲区<span class="token number">1</span>：<span class="token operator">|</span>qrstuvwx<span class="token operator">|</span>  <span class="token comment">// 原来缓冲区1的内容被覆盖，a-h丢失了！</span>
缓冲区<span class="token number">2</span>：<span class="token operator">|</span>ijklmnop<span class="token operator">|</span>
</code></pre><p>让我们看一个具体例子：</p>
<p>假设有这样的源代码：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><p>如果缓冲区大小是8，处理过程是这样的：</p>
<ol>
<li>
<p>初始状态：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>缓冲区1：|int a = |
缓冲区2：|10;     |
lexemeBegin: ↑
forward: ↑
</code></pre></li>
<li>
<p>识别<code>int</code>的过程：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>缓冲区1：|int a = |
缓冲区2：|10;     |
lexemeBegin: ↑
forward: 向前移动直到遇到空格，此时指向空格位置
</code></pre></li>
<li>
<p>识别完<code>int</code>后：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>缓冲区1：|int a = |
缓冲区2：|10;     |
lexemeBegin = forward: ↑（指向空格）
</code></pre></li>
<li>
<p>跳过空格：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>缓冲区1：|int a = |
缓冲区2：|10;     |
lexemeBegin和forward都移动到a的位置：
     ↑
</code></pre></li>
</ol>
<p>双缓冲技术的优点：</p>
<ol>
<li>
<p>效率高：</p>
<ul>
<li>在处理一个缓冲区的同时可以加载另一个缓冲区</li>
<li>减少了I/O等待时间</li>
<li>实现了流式处理</li>
</ul>
</li>
<li>
<p>实现简单：</p>
<ul>
<li>只需要两个指针和简单的边界检查</li>
<li>维护成本低</li>
</ul>
</li>
</ol>
<p>需要注意的细节：</p>
<ol>
<li>
<p>缓冲区大小的选择：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFFER_SIZE</span> <span class="token expression"><span class="token number">4096</span>  </span><span class="token comment">// 通常选择系统页大小的整数倍</span></span>
</code></pre></li>
<li>
<p>EOF标记的处理：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EOF_MARKER</span> <span class="token char">'\0'</span></span>

<span class="token keyword keyword-void">void</span> <span class="token function">markEOF</span><span class="token punctuation">(</span>Buffer <span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  buf<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>BUFFER_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> EOF_MARKER<span class="token punctuation">;</span>
  buf<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>BUFFER_SIZE <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> EOF_MARKER<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li>
<li>
<p>词素长度限制：必须保证词素长度不超过<code>BUFFER_SIZE</code>，这样才能确保在缓冲区切换时不会丢失信息。</p>
</li>
</ol>
<hr>
<p>超前搜索（lookahead）是词法分析中一种重要的技术，用于解决某些模式识别时的歧义问题。我来详细解释一下。</p>
<p>在词法分析过程中，有时仅凭当前读到的字符无法确定应该生成什么词法单元，需要往前多看几个字符才能做出正确判断。我们来看几个具体的例子：</p>
<ol>
<li>
<p>区分赋值符号和相等判断</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>x <span class="token operator">=</span> y    <span class="token comment">// 赋值符号</span>
<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> y<span class="token punctuation">)</span>  <span class="token comment">// 相等判断</span>
</code></pre><p>当扫描到第一个<code>=</code>时，需要再往前看一个字符，才能确定这是赋值符号还是相等判断的开始。</p>
</li>
<li>
<p>区分大于号和右移运算</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> y<span class="token punctuation">)</span>     <span class="token comment">// 大于号</span>
<span class="token keyword keyword-int">int</span> z <span class="token operator">=</span> x <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 右移运算</span>
</code></pre><p>遇到<code>&gt;</code>时需要往前看一个字符。</p>
</li>
<li>
<p>区分标识符和关键字</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> if_count<span class="token punctuation">;</span>  <span class="token comment">// if_count是标识符</span>
<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// if是关键字</span>
</code></pre><p>需要读完整个单词才能判断。</p>
</li>
</ol>
<p>状态转移图可以帮助我们理解这个过程：</p>
<p class="dot"><!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<!-- Generated by graphviz version 9.0.0 (20230911.1827)
 -->
<!-- Title: lookahead Pages: 1 -->
<svg width="432pt" height="286pt" viewBox="0.00 0.00 432.39 286.17" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 282.17)">
<title>lookahead</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-282.17 428.39,-282.17 428.39,4 -4,4"></polygon>
<!-- start -->
<g id="node1" class="node">
<title>start</title>
</g>
<!-- s0 -->
<g id="node2" class="node">
<title>s0</title>
<ellipse fill="none" stroke="black" cx="109" cy="-150.36" rx="18" ry="18"></ellipse>
<text text-anchor="middle" x="109" y="-146.16" font-family="Times,serif" font-size="14.00">0</text>
</g>
<!-- start&#45;&gt;s0 -->
<g id="edge1" class="edge">
<title>start-&gt;s0</title>
<path fill="none" stroke="black" d="M53.75,-150.36C61.85,-150.36 70.85,-150.36 79.16,-150.36"></path>
<polygon fill="black" stroke="black" points="79.12,-153.86 89.12,-150.36 79.12,-146.86 79.12,-153.86"></polygon>
</g>
<!-- s1 -->
<g id="node3" class="node">
<title>s1</title>
<ellipse fill="none" stroke="black" cx="188.9" cy="-150.36" rx="18" ry="18"></ellipse>
<text text-anchor="middle" x="188.9" y="-146.16" font-family="Times,serif" font-size="14.00">1</text>
</g>
<!-- s0&#45;&gt;s1 -->
<g id="edge2" class="edge">
<title>s0-&gt;s1</title>
<path fill="none" stroke="black" d="M127.29,-150.36C136.67,-150.36 148.5,-150.36 159.22,-150.36"></path>
<polygon fill="black" stroke="black" points="159.14,-153.86 169.14,-150.36 159.14,-146.86 159.14,-153.86"></polygon>
<text text-anchor="middle" x="148.95" y="-154.56" font-family="Times,serif" font-size="14.00">=</text>
</g>
<!-- s2 -->
<g id="node4" class="node">
<title>s2</title>
<ellipse fill="none" stroke="black" cx="348.02" cy="-224.36" rx="49.8" ry="49.8"></ellipse>
<ellipse fill="none" stroke="black" cx="348.02" cy="-224.36" rx="53.8" ry="53.8"></ellipse>
<text text-anchor="middle" x="348.02" y="-228.56" font-family="Times,serif" font-size="14.00">==</text>
<text text-anchor="middle" x="348.02" y="-211.76" font-family="Times,serif" font-size="14.00">TOK_EQ</text>
</g>
<!-- s1&#45;&gt;s2 -->
<g id="edge3" class="edge">
<title>s1-&gt;s2</title>
<path fill="none" stroke="black" d="M205.54,-157.73C224.84,-166.82 258.77,-182.8 288.56,-196.83"></path>
<polygon fill="black" stroke="black" points="286.99,-199.96 297.53,-201.05 289.98,-193.63 286.99,-199.96"></polygon>
<text text-anchor="middle" x="239.28" y="-182.56" font-family="Times,serif" font-size="14.00">=</text>
</g>
<!-- s3 -->
<g id="node5" class="node">
<title>s3</title>
<ellipse fill="none" stroke="black" cx="348.02" cy="-76.36" rx="72.36" ry="72.36"></ellipse>
<ellipse fill="none" stroke="black" cx="348.02" cy="-76.36" rx="76.36" ry="76.36"></ellipse>
<text text-anchor="middle" x="348.02" y="-80.56" font-family="Times,serif" font-size="14.00">=</text>
<text text-anchor="middle" x="348.02" y="-63.76" font-family="Times,serif" font-size="14.00">TOK_ASSIGN</text>
</g>
<!-- s1&#45;&gt;s3 -->
<g id="edge4" class="edge">
<title>s1-&gt;s3</title>
<path fill="none" stroke="black" d="M205.54,-143C220.55,-135.93 244.4,-124.69 268.28,-113.45"></path>
<polygon fill="black" stroke="black" points="269.56,-116.71 277.12,-109.29 266.58,-110.38 269.56,-116.71"></polygon>
<text text-anchor="middle" x="239.28" y="-136.56" font-family="Times,serif" font-size="14.00">other</text>
</g>
</g>
</svg>
</p><p>让我们看一个更复杂的例子，需要处理C语言中的注释：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 单行注释</span>
<span class="token keyword keyword-int">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token comment">/* 多行
   注释 */</span>
<span class="token keyword keyword-int">int</span> y <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
</code></pre><p>这种情况下的状态转移：</p>
<p class="dot"><!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<!-- Generated by graphviz version 9.0.0 (20230911.1827)
 -->
<!-- Title: comment Pages: 1 -->
<svg width="395pt" height="195pt" viewBox="0.00 0.00 395.17 194.74" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 190.74)">
<title>comment</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-190.74 391.17,-190.74 391.17,4 -4,4"></polygon>
<!-- start -->
<g id="node1" class="node">
<title>start</title>
</g>
<!-- s0 -->
<g id="node2" class="node">
<title>s0</title>
<ellipse fill="none" stroke="black" cx="109" cy="-38.94" rx="18" ry="18"></ellipse>
<text text-anchor="middle" x="109" y="-34.74" font-family="Times,serif" font-size="14.00">0</text>
</g>
<!-- start&#45;&gt;s0 -->
<g id="edge1" class="edge">
<title>start-&gt;s0</title>
<path fill="none" stroke="black" d="M53.75,-38.94C61.85,-38.94 70.85,-38.94 79.16,-38.94"></path>
<polygon fill="black" stroke="black" points="79.12,-42.44 89.12,-38.94 79.12,-35.44 79.12,-42.44"></polygon>
</g>
<!-- s1 -->
<g id="node3" class="node">
<title>s1</title>
<ellipse fill="none" stroke="black" cx="184.89" cy="-91.94" rx="18" ry="18"></ellipse>
<text text-anchor="middle" x="184.89" y="-87.74" font-family="Times,serif" font-size="14.00">1</text>
</g>
<!-- s0&#45;&gt;s1 -->
<g id="edge2" class="edge">
<title>s0-&gt;s1</title>
<path fill="none" stroke="black" d="M124.25,-49.16C134.47,-56.49 148.48,-66.54 160.35,-75.06"></path>
<polygon fill="black" stroke="black" points="158.29,-77.89 168.46,-80.87 162.37,-72.2 158.29,-77.89"></polygon>
<text text-anchor="middle" x="146.94" y="-70.14" font-family="Times,serif" font-size="14.00">/</text>
</g>
<!-- s2 -->
<g id="node4" class="node">
<title>s2</title>
<ellipse fill="none" stroke="black" cx="267.89" cy="-40.94" rx="18" ry="18"></ellipse>
<ellipse fill="none" stroke="black" cx="267.89" cy="-40.94" rx="22" ry="22"></ellipse>
<text text-anchor="middle" x="267.89" y="-36.74" font-family="Times,serif" font-size="14.00">2</text>
</g>
<!-- s1&#45;&gt;s2 -->
<g id="edge3" class="edge">
<title>s1-&gt;s2</title>
<path fill="none" stroke="black" d="M200.75,-82.59C211.52,-75.81 226.4,-66.43 239.33,-58.3"></path>
<polygon fill="black" stroke="black" points="240.85,-61.48 247.44,-53.19 237.12,-55.55 240.85,-61.48"></polygon>
<text text-anchor="middle" x="224.39" y="-74.14" font-family="Times,serif" font-size="14.00">/</text>
</g>
<!-- s3 -->
<g id="node5" class="node">
<title>s3</title>
<ellipse fill="none" stroke="black" cx="267.89" cy="-133.94" rx="18" ry="18"></ellipse>
<text text-anchor="middle" x="267.89" y="-129.74" font-family="Times,serif" font-size="14.00">3</text>
</g>
<!-- s1&#45;&gt;s3 -->
<g id="edge4" class="edge">
<title>s1-&gt;s3</title>
<path fill="none" stroke="black" d="M201.51,-100.04C212.82,-105.91 228.38,-113.97 241.47,-120.76"></path>
<polygon fill="black" stroke="black" points="239.49,-123.68 249.98,-125.17 242.71,-117.46 239.49,-123.68"></polygon>
<text text-anchor="middle" x="224.39" y="-117.14" font-family="Times,serif" font-size="14.00">*</text>
</g>
<!-- s2&#45;&gt;s0 -->
<g id="edge6" class="edge">
<title>s2-&gt;s0</title>
<path fill="none" stroke="black" d="M245.42,-40.67C217.72,-40.32 169.45,-39.7 138.64,-39.31"></path>
<polygon fill="black" stroke="black" points="138.95,-35.81 128.9,-39.18 138.86,-42.81 138.95,-35.81"></polygon>
<text text-anchor="middle" x="184.89" y="-45.14" font-family="Times,serif" font-size="14.00">\n</text>
</g>
<!-- s2&#45;&gt;s2 -->
<g id="edge5" class="edge">
<title>s2-&gt;s2</title>
<path fill="none" stroke="black" d="M259.93,-61.93C258.95,-72.03 261.6,-80.94 267.89,-80.94 271.62,-80.94 274.07,-77.8 275.24,-73.14"></path>
<polygon fill="black" stroke="black" points="278.72,-73.62 275.77,-63.45 271.73,-73.24 278.72,-73.62"></polygon>
<text text-anchor="middle" x="267.89" y="-85.14" font-family="Times,serif" font-size="14.00">not \n</text>
</g>
<!-- s3&#45;&gt;s3 -->
<g id="edge7" class="edge">
<title>s3-&gt;s3</title>
<path fill="none" stroke="black" d="M260.24,-150.61C258.54,-160.57 261.09,-169.94 267.89,-169.94 271.93,-169.94 274.46,-166.64 275.5,-161.87"></path>
<polygon fill="black" stroke="black" points="279,-162.13 275.53,-152.12 272,-162.11 279,-162.13"></polygon>
<text text-anchor="middle" x="267.89" y="-174.14" font-family="Times,serif" font-size="14.00">not *</text>
</g>
<!-- s4 -->
<g id="node6" class="node">
<title>s4</title>
<ellipse fill="none" stroke="black" cx="369.17" cy="-93.94" rx="18" ry="18"></ellipse>
<text text-anchor="middle" x="369.17" y="-89.74" font-family="Times,serif" font-size="14.00">4</text>
</g>
<!-- s3&#45;&gt;s4 -->
<g id="edge8" class="edge">
<title>s3-&gt;s4</title>
<path fill="none" stroke="black" d="M278.99,-119.31C285.98,-110.54 296.11,-100.14 307.89,-95.14 317.72,-90.97 329.3,-89.93 339.66,-90.2"></path>
<polygon fill="black" stroke="black" points="339.37,-93.68 349.58,-90.89 339.85,-86.7 339.37,-93.68"></polygon>
<text text-anchor="middle" x="320.53" y="-100.14" font-family="Times,serif" font-size="14.00">*</text>
</g>
<!-- s4&#45;&gt;s0 -->
<g id="edge10" class="edge">
<title>s4-&gt;s0</title>
<path fill="none" stroke="black" d="M359.44,-78.56C347,-58.39 322.06,-23.94 289.89,-9.94 238.1,12.59 171.06,-10.41 135.22,-26.39"></path>
<polygon fill="black" stroke="black" points="134.12,-23.05 126.53,-30.43 137.07,-29.4 134.12,-23.05"></polygon>
<text text-anchor="middle" x="224.39" y="-6.14" font-family="Times,serif" font-size="14.00">/</text>
</g>
<!-- s4&#45;&gt;s3 -->
<g id="edge9" class="edge">
<title>s4-&gt;s3</title>
<path fill="none" stroke="black" d="M353.07,-102.32C346.98,-105.53 339.83,-109.11 333.17,-111.94 321.28,-117 307.81,-121.76 296.27,-125.54"></path>
<polygon fill="black" stroke="black" points="295.42,-122.14 286.96,-128.52 297.55,-128.81 295.42,-122.14"></polygon>
<text text-anchor="middle" x="320.53" y="-126.14" font-family="Times,serif" font-size="14.00">not /</text>
</g>
</g>
</svg>
</p><p>超前搜索在处理某些特殊情况时也很重要：</p>
<ol>
<li>
<p>字符串常量中的转义序列</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token string">"Hello\n"</span>   <span class="token comment">// \n是换行符</span>
<span class="token string">"Path\\file"</span> <span class="token comment">// \\是反斜杠</span>
</code></pre></li>
<li>
<p>浮点数的识别</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token number">123.456</span>     <span class="token comment">// 常规浮点数</span>
<span class="token number">123.</span>        <span class="token comment">// 需要超前搜索确认后面没有数字</span>
</code></pre></li>
<li>
<p>科学记数法</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token number">1.23e+4</span>     <span class="token comment">// 需要处理e/E后面的符号和数字</span>
</code></pre></li>
</ol>
<p>编译器生成工具（如<code>flex</code>）会自动处理这些超前搜索的情况：</p>
<pre data-role="codeBlock" data-info="lex" class="language-lex lex"><code>%%
"="    { return TOK_ASSIGN; }
"=="   { return TOK_EQ; }
"&gt;"    { return TOK_GT; }
"&gt;&gt;"   { return TOK_RSHIFT; }
"//"   { /* 跳过单行注释 */ }
"/*"   { /* 处理多行注释 */ }
%%
</code></pre><p>在实际编译器中，超前搜索的效率问题也需要考虑：</p>
<ol>
<li>缓冲区大小的选择</li>
<li>文件读取策略（如分块读取）</li>
<li>是否需要回退机制</li>
<li>错误处理和恢复策略</li>
</ol>
<p>合理使用超前搜索可以：</p>
<ul>
<li>正确处理词法分析中的歧义</li>
<li>提高词法分析的准确性</li>
<li>简化后续的语法分析工作</li>
</ul>
<p>但也要注意不要过度使用，因为过多的超前搜索会降低词法分析的效率。通常1-2个字符的超前搜索就能解决大多数问题。</p>
<hr>
<p>让我详细解释一下最长匹配（Longest Match）和最先匹配（First Match）这两个词法分析中的重要原则。</p>
<p>最长匹配原则：当一个字符序列可以匹配多个模式时，选择最长的那个匹配。</p>
<p>例如，考虑这段C代码：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> ifelseif <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><p>这里的<code>ifelseif</code>可以有多种分割方式：</p>
<ul>
<li><code>if</code>（关键字）+ <code>elseif</code>（标识符）</li>
<li><code>ifelseif</code>（整个作为标识符）</li>
</ul>
<p>根据最长匹配原则，词法分析器会将整个<code>ifelseif</code>识别为一个标识符，而不是把它分割成多个部分。</p>
<p>再看一个例子：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>x <span class="token operator">=</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token comment">// 连续的等号</span>
</code></pre><p>可能的匹配方式：</p>
<ul>
<li><code>=</code>（赋值）+ <code>====</code></li>
<li><code>==</code>（相等）+ <code>===</code></li>
<li><code>===</code>+ <code>==</code></li>
<li><code>====</code>+ <code>=</code></li>
<li><code>=====</code>（整体）</li>
</ul>
<p>最长匹配原则会尝试找出最长的合法匹配序列，在这个例子中：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>&lt;id, "x"&gt;
&lt;assign_op, "="&gt;
&lt;eq_op, "=="&gt;
&lt;eq_op, "=="&gt;
&lt;assign_op, "="&gt;
&lt;id, "y"&gt;
</code></pre><p>最先匹配原则：当多个模式都能匹配相同长度的输入时，选择在模式规则中最先定义的那个。</p>
<p>看这个例子：</p>
<pre data-role="codeBlock" data-info="lex" class="language-lex lex"><code>%%
if       { return IF; }
[a-z]+   { return ID; }
%%
</code></pre><p>对于输入<code>if</code>，它既可以匹配关键字<code>if</code>，也可以匹配标识符模式<code>[a-z]+</code>。根据最先匹配原则，由于<code>if</code>规则在前面，所以会被识别为关键字而不是标识符。</p>
<p>让我们通过一个更复杂的例子来说明这两个原则：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> test <span class="token operator">=</span> <span class="token number">1234.567e-10</span><span class="token punctuation">;</span>
</code></pre><p>词法分析时的决策过程：</p>
<ol>
<li>
<p>数字<code>1234.567e-10</code>的识别：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>1234     // 可以是整数
1234.    // 可以是浮点数
1234.567 // 可以是浮点数
1234.567e // 不完整的科学记数法
1234.567e-10 // 完整的科学记数法
</code></pre><p>根据最长匹配原则，会选择最长的合法形式<code>1234.567e-10</code>作为一个浮点数常量。</p>
</li>
<li>
<p>标识符和关键字的识别：</p>
<pre data-role="codeBlock" data-info="lex" class="language-lex lex"><code>int      return INT;
[a-z]+   return ID;
</code></pre><ul>
<li><code>int</code>既可以匹配关键字规则，也可以匹配标识符规则</li>
<li><code>test</code>只能匹配标识符规则</li>
</ul>
</li>
</ol>
<p>实现这两个原则的状态转移图示例：</p>
<p class="dot"><!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<!-- Generated by graphviz version 9.0.0 (20230911.1827)
 -->
<!-- Title: number Pages: 1 -->
<svg width="527pt" height="87pt" viewBox="0.00 0.00 527.41 86.80" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 82.8)">
<title>number</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-82.8 523.41,-82.8 523.41,4 -4,4"></polygon>
<!-- start -->
<g id="node1" class="node">
<title>start</title>
</g>
<!-- s0 -->
<g id="node2" class="node">
<title>s0</title>
<ellipse fill="none" stroke="black" cx="109" cy="-22" rx="18" ry="18"></ellipse>
<text text-anchor="middle" x="109" y="-17.8" font-family="Times,serif" font-size="14.00">0</text>
</g>
<!-- start&#45;&gt;s0 -->
<g id="edge1" class="edge">
<title>start-&gt;s0</title>
<path fill="none" stroke="black" d="M53.75,-22C61.85,-22 70.85,-22 79.16,-22"></path>
<polygon fill="black" stroke="black" points="79.12,-25.5 89.12,-22 79.12,-18.5 79.12,-25.5"></polygon>
</g>
<!-- s1 -->
<g id="node3" class="node">
<title>s1</title>
<ellipse fill="none" stroke="black" cx="210.67" cy="-22" rx="18" ry="18"></ellipse>
<ellipse fill="none" stroke="black" cx="210.67" cy="-22" rx="22" ry="22"></ellipse>
<text text-anchor="middle" x="210.67" y="-17.8" font-family="Times,serif" font-size="14.00">1</text>
</g>
<!-- s0&#45;&gt;s1 -->
<g id="edge2" class="edge">
<title>s0-&gt;s1</title>
<path fill="none" stroke="black" d="M127.36,-22C141,-22 160.4,-22 176.94,-22"></path>
<polygon fill="black" stroke="black" points="176.84,-25.5 186.84,-22 176.84,-18.5 176.84,-25.5"></polygon>
<text text-anchor="middle" x="157.83" y="-26.2" font-family="Times,serif" font-size="14.00">digit</text>
</g>
<!-- s1&#45;&gt;s1 -->
<g id="edge3" class="edge">
<title>s1-&gt;s1</title>
<path fill="none" stroke="black" d="M203.03,-42.99C202.09,-53.09 204.63,-62 210.67,-62 214.25,-62 216.6,-58.86 217.73,-54.19"></path>
<polygon fill="black" stroke="black" points="221.21,-54.67 218.23,-44.5 214.22,-54.31 221.21,-54.67"></polygon>
<text text-anchor="middle" x="210.67" y="-66.2" font-family="Times,serif" font-size="14.00">digit</text>
</g>
<!-- s2 -->
<g id="node4" class="node">
<title>s2</title>
<ellipse fill="none" stroke="black" cx="294.17" cy="-22" rx="18" ry="18"></ellipse>
<ellipse fill="none" stroke="black" cx="294.17" cy="-22" rx="22" ry="22"></ellipse>
<text text-anchor="middle" x="294.17" y="-17.8" font-family="Times,serif" font-size="14.00">2</text>
</g>
<!-- s1&#45;&gt;s2 -->
<g id="edge4" class="edge">
<title>s1-&gt;s2</title>
<path fill="none" stroke="black" d="M233.08,-22C241.5,-22 251.36,-22 260.63,-22"></path>
<polygon fill="black" stroke="black" points="260.39,-25.5 270.39,-22 260.39,-18.5 260.39,-25.5"></polygon>
<text text-anchor="middle" x="252.42" y="-26.2" font-family="Times,serif" font-size="14.00">.</text>
</g>
<!-- s2&#45;&gt;s2 -->
<g id="edge5" class="edge">
<title>s2-&gt;s2</title>
<path fill="none" stroke="black" d="M286.53,-42.99C285.59,-53.09 288.13,-62 294.17,-62 297.75,-62 300.1,-58.86 301.23,-54.19"></path>
<polygon fill="black" stroke="black" points="304.71,-54.67 301.73,-44.5 297.72,-54.31 304.71,-54.67"></polygon>
<text text-anchor="middle" x="294.17" y="-66.2" font-family="Times,serif" font-size="14.00">digit</text>
</g>
<!-- s3 -->
<g id="node5" class="node">
<title>s3</title>
<ellipse fill="none" stroke="black" cx="391.74" cy="-22" rx="18" ry="18"></ellipse>
<ellipse fill="none" stroke="black" cx="391.74" cy="-22" rx="22" ry="22"></ellipse>
<text text-anchor="middle" x="391.74" y="-17.8" font-family="Times,serif" font-size="14.00">3</text>
</g>
<!-- s2&#45;&gt;s3 -->
<g id="edge6" class="edge">
<title>s2-&gt;s3</title>
<path fill="none" stroke="black" d="M316.38,-22C328.54,-22 344.08,-22 357.8,-22"></path>
<polygon fill="black" stroke="black" points="357.74,-25.5 367.74,-22 357.74,-18.5 357.74,-25.5"></polygon>
<text text-anchor="middle" x="342.95" y="-26.2" font-family="Times,serif" font-size="14.00">e|E</text>
</g>
<!-- s3&#45;&gt;s3 -->
<g id="edge9" class="edge">
<title>s3-&gt;s3</title>
<path fill="none" stroke="black" d="M382.86,-42.58C381.63,-52.84 384.59,-62 391.74,-62 395.98,-62 398.75,-58.77 400.04,-54"></path>
<polygon fill="black" stroke="black" points="403.53,-54.26 400.54,-44.09 396.54,-53.9 403.53,-54.26"></polygon>
<text text-anchor="middle" x="391.74" y="-66.2" font-family="Times,serif" font-size="14.00">+|-</text>
</g>
<!-- s4 -->
<g id="node6" class="node">
<title>s4</title>
<ellipse fill="none" stroke="black" cx="497.41" cy="-22" rx="18" ry="18"></ellipse>
<ellipse fill="none" stroke="black" cx="497.41" cy="-22" rx="22" ry="22"></ellipse>
<text text-anchor="middle" x="497.41" y="-17.8" font-family="Times,serif" font-size="14.00">4</text>
</g>
<!-- s3&#45;&gt;s4 -->
<g id="edge7" class="edge">
<title>s3-&gt;s4</title>
<path fill="none" stroke="black" d="M414.22,-22C428.53,-22 447.62,-22 463.8,-22"></path>
<polygon fill="black" stroke="black" points="463.44,-25.5 473.44,-22 463.44,-18.5 463.44,-25.5"></polygon>
<text text-anchor="middle" x="444.57" y="-26.2" font-family="Times,serif" font-size="14.00">digit</text>
</g>
<!-- s4&#45;&gt;s4 -->
<g id="edge8" class="edge">
<title>s4-&gt;s4</title>
<path fill="none" stroke="black" d="M487.85,-42.17C486.38,-52.6 489.56,-62 497.41,-62 502.19,-62 505.24,-58.51 506.56,-53.42"></path>
<polygon fill="black" stroke="black" points="510.04,-53.8 506.91,-43.68 503.05,-53.55 510.04,-53.8"></polygon>
<text text-anchor="middle" x="497.41" y="-66.2" font-family="Times,serif" font-size="14.00">digit</text>
</g>
</g>
</svg>
</p><p>在实际编译器中实现这两个原则：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-struct">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> type<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>lexeme<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> line<span class="token punctuation">;</span>
<span class="token punctuation">}</span> Token<span class="token punctuation">;</span>

Token<span class="token operator">*</span> <span class="token function">getNextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> buffer<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    Token <span class="token operator">*</span>longest <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEOF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-char">char</span> c <span class="token operator">=</span> <span class="token function">peekNextChar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        buffer<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>
        buffer<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 尝试所有可能的模式</span>
        Token <span class="token operator">*</span>current <span class="token operator">=</span> <span class="token function">tryMatch</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 保存最长的合法匹配</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>longest <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> <span class="token function">strlen</span><span class="token punctuation">(</span>current<span class="token operator">-&gt;</span>lexeme<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>longest<span class="token operator">-&gt;</span>lexeme<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                longest <span class="token operator">=</span> current<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果当前序列无法匹配，返回之前找到的最长匹配</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>longest <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword keyword-return">return</span> longest<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        
        <span class="token function">consumeChar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> longest<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>这两个原则的重要性：</p>
<ol>
<li>
<p>消除歧义：</p>
<ul>
<li>明确定义如何处理可能有多种解释的输入</li>
<li>保证词法分析结果的一致性</li>
</ul>
</li>
<li>
<p>提高效率：</p>
<ul>
<li>避免不必要的回溯</li>
<li>简化词法分析器的实现</li>
</ul>
</li>
<li>
<p>符合程序员直觉：</p>
<ul>
<li>大多数编程语言的设计都遵循这两个原则</li>
<li>使代码更易于理解和维护</li>
</ul>
</li>
</ol>
<hr>
<p>LEX是一个词法分析器生成工具，它能根据用户定义的正则表达式规则自动生成词法分析器的C代码。我来详细解释它的工作原理和使用方法。</p>
<p>LEX源程序的基本结构分为三个部分：</p>
<pre data-role="codeBlock" data-info="lex" class="language-lex lex"><code>定义部分
%%
规则部分
%%
C代码部分
</code></pre><ol>
<li>
<p>定义部分：包含变量定义、头文件包含等</p>
<pre data-role="codeBlock" data-info="lex" class="language-lex lex"><code>%{
#include &lt;stdio.h&gt;
int count = 0;
%}

/* 正则表达式定义 */
digit    [0-9]
letter   [a-zA-Z]
id       {letter}({letter}|{digit})*
number   {digit}+(\.{digit}+)?
</code></pre></li>
<li>
<p>规则部分：包含模式和动作</p>
<pre data-role="codeBlock" data-info="lex" class="language-lex lex"><code>%%
{id}        { printf("标识符: %s\n", yytext); }
{number}    { printf("数字: %s\n", yytext); }
"+"         { printf("加号\n"); }
"-"         { printf("减号\n"); }
"="         { printf("等号\n"); }
[ \t\n]     { /* 忽略空白字符 */ }
.           { printf("未知字符: %s\n", yytext); }
%%
</code></pre></li>
<li>
<p>C代码部分：包含主函数和辅助函数</p>
<pre data-role="codeBlock" data-info="lex" class="language-lex lex"><code>int main() {
    yylex();
    return 0;
}

int yywrap() {
    return 1;
}
</code></pre></li>
</ol>
<p>让我们看一个完整的例子，这个LEX程序用来识别简单的算术表达式：</p>
<pre data-role="codeBlock" data-info="lex" class="language-lex lex"><code>%{
#include &lt;stdio.h&gt;
enum {
    TOK_ID = 1,
    TOK_NUM,
    TOK_PLUS,
    TOK_MINUS,
    TOK_MULT,
    TOK_DIV,
    TOK_ASSIGN
};
%}

digit   [0-9]
number  {digit}+(\.{digit}+)?
letter  [a-zA-Z]
id      {letter}({letter}|{digit})*
ws      [ \t\n]

%%
{number}    { printf("&lt;TOK_NUM, %s&gt;\n", yytext); return TOK_NUM; }
{id}        { printf("&lt;TOK_ID, %s&gt;\n", yytext); return TOK_ID; }
"+"         { printf("&lt;TOK_PLUS&gt;\n"); return TOK_PLUS; }
"-"         { printf("&lt;TOK_MINUS&gt;\n"); return TOK_MINUS; }
"*"         { printf("&lt;TOK_MULT&gt;\n"); return TOK_MULT; }
"/"         { printf("&lt;TOK_DIV&gt;\n"); return TOK_DIV; }
"="         { printf("&lt;TOK_ASSIGN&gt;\n"); return TOK_ASSIGN; }
{ws}        { /* 忽略空白字符 */ }
.           { printf("Error: unexpected character %s\n", yytext); }

%%

int main() {
    yylex();
    return 0;
}

int yywrap() {
    return 1;
}
</code></pre><p>使用这个词法分析器处理以下输入：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>sum <span class="token operator">=</span> <span class="token number">100</span> <span class="token operator">+</span> count <span class="token operator">*</span> <span class="token number">2</span>
</code></pre><p>会得到这样的输出：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>&lt;TOK_ID, sum&gt;
&lt;TOK_ASSIGN&gt;
&lt;TOK_NUM, 100&gt;
&lt;TOK_PLUS&gt;
&lt;TOK_ID, count&gt;
&lt;TOK_MULT&gt;
&lt;TOK_NUM, 2&gt;
</code></pre><p>LEX的一些重要特性：</p>
<ol>
<li>
<p>自动变量和函数：</p>
<ul>
<li><code>yytext</code>：当前匹配的文本</li>
<li><code>yyleng</code>：当前匹配的文本长度</li>
<li><code>yylex()</code>：开始词法分析的函数</li>
</ul>
</li>
<li>
<p>正则表达式规则：</p>
<pre data-role="codeBlock" data-info="lex" class="language-lex lex"><code>"while"     { return WHILE; }      // 精确匹配
[0-9]+      { return NUMBER; }     // 一个或多个数字
[a-z][a-z0-9]*  { return ID; }     // 标识符
[ \t\n]+    { }                    // 忽略空白字符
.           { return ERROR; }       // 任意单个字符
</code></pre></li>
<li>
<p>状态和条件：</p>
<pre data-role="codeBlock" data-info="lex" class="language-lex lex"><code>%s STRING
%%
\"         { BEGIN STRING; }
&lt;STRING&gt;\" { BEGIN INITIAL; }
&lt;STRING&gt;.  { /* 处理字符串内容 */ }
</code></pre></li>
<li>
<p>与YACC的集成：</p>
<pre data-role="codeBlock" data-info="lex" class="language-lex lex"><code>%{
#include "y.tab.h"  // YACC生成的头文件
%}
%%
[0-9]+  { yylval = atoi(yytext); return NUMBER; }
</code></pre></li>
</ol>
<p>LEX的工作流程：</p>
<ol>
<li>LEX源文件（<code>.l</code>）→ LEX编译器 → C源文件（<code>lex.yy.c</code>）</li>
<li>C源文件编译 → 可执行的词法分析器</li>
<li>词法分析器读取输入文本 → 生成词法单元序列</li>
</ol>
<p>使用命令：</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code>lex example.l        <span class="token comment"># 生成lex.yy.c</span>
gcc lex.yy.c <span class="token parameter variable">-o</span> lexer <span class="token parameter variable">-ll</span>   <span class="token comment"># 编译（-ll链接lex库）</span>
./lexer <span class="token operator">&lt;</span> input.txt  <span class="token comment"># 运行词法分析器</span>
</code></pre><p>最后要注意的是，现代编译器开发中经常使用LEX的改进版本flex（Fast Lexical Analyzer Generator），它提供了更多功能和更好的性能。但基本概念和使用方法是一样的。</p>
<hr>
<p>让我详细讲解LEX的构造思想，通过这几个步骤来说明。</p>
<ol>
<li>
<p>对token按类构造状态转换图</p>
<p class="dot"><!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<!-- Generated by graphviz version 9.0.0 (20230911.1827)
 -->
<!-- Title: TokenDFA Pages: 1 -->
<svg width="387pt" height="393pt" viewBox="0.00 0.00 387.29 393.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 389)">
<title>TokenDFA</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-389 383.29,-389 383.29,4 -4,4"></polygon>
<g id="clust3" class="cluster">
<title>cluster_op</title>
<polygon fill="none" stroke="black" points="8,-282 8,-377 190.1,-377 190.1,-282 8,-282"></polygon>
<text text-anchor="middle" x="99.05" y="-360.4" font-family="Times,serif" font-size="14.00">运算符</text>
</g>
<g id="clust1" class="cluster">
<title>cluster_id</title>
<polygon fill="none" stroke="black" points="8,-8 8,-137 190.1,-137 190.1,-8 8,-8"></polygon>
<text text-anchor="middle" x="99.05" y="-120.4" font-family="Times,serif" font-size="14.00">标识符</text>
</g>
<g id="clust2" class="cluster">
<title>cluster_num</title>
<polygon fill="none" stroke="black" points="8,-145 8,-274 371.29,-274 371.29,-145 8,-145"></polygon>
<text text-anchor="middle" x="189.64" y="-257.4" font-family="Times,serif" font-size="14.00">数字</text>
</g>
<!-- id_start -->
<g id="node1" class="node">
<title>id_start</title>
<ellipse fill="none" stroke="black" cx="37.24" cy="-43" rx="21.24" ry="21.24"></ellipse>
<text text-anchor="middle" x="37.24" y="-38.8" font-family="Times,serif" font-size="14.00">S1</text>
</g>
<!-- id_accept -->
<g id="node2" class="node">
<title>id_accept</title>
<ellipse fill="none" stroke="black" cx="155.26" cy="-43" rx="22.84" ry="22.84"></ellipse>
<ellipse fill="none" stroke="black" cx="155.26" cy="-43" rx="26.84" ry="26.84"></ellipse>
<text text-anchor="middle" x="155.26" y="-38.8" font-family="Times,serif" font-size="14.00">A1</text>
</g>
<!-- id_start&#45;&gt;id_accept -->
<g id="edge1" class="edge">
<title>id_start-&gt;id_accept</title>
<path fill="none" stroke="black" d="M58.71,-43C74.77,-43 97.54,-43 116.83,-43"></path>
<polygon fill="black" stroke="black" points="116.78,-46.5 126.78,-43 116.78,-39.5 116.78,-46.5"></polygon>
<text text-anchor="middle" x="93.45" y="-47.2" font-family="Times,serif" font-size="14.00">letter</text>
</g>
<!-- id_accept&#45;&gt;id_accept -->
<g id="edge2" class="edge">
<title>id_accept-&gt;id_accept</title>
<path fill="none" stroke="black" d="M146.58,-68.8C146.08,-79.15 148.98,-87.84 155.26,-87.84 158.99,-87.84 161.52,-84.78 162.86,-80.12"></path>
<polygon fill="black" stroke="black" points="166.33,-80.6 163.8,-70.31 159.36,-79.93 166.33,-80.6"></polygon>
<text text-anchor="middle" x="155.26" y="-92.04" font-family="Times,serif" font-size="14.00">letter,digit</text>
</g>
<!-- num_start -->
<g id="node3" class="node">
<title>num_start</title>
<ellipse fill="none" stroke="black" cx="37.24" cy="-180" rx="21.24" ry="21.24"></ellipse>
<text text-anchor="middle" x="37.24" y="-175.8" font-family="Times,serif" font-size="14.00">S2</text>
</g>
<!-- num_accept -->
<g id="node4" class="node">
<title>num_accept</title>
<ellipse fill="none" stroke="black" cx="155.26" cy="-180" rx="22.84" ry="22.84"></ellipse>
<ellipse fill="none" stroke="black" cx="155.26" cy="-180" rx="26.84" ry="26.84"></ellipse>
<text text-anchor="middle" x="155.26" y="-175.8" font-family="Times,serif" font-size="14.00">A2</text>
</g>
<!-- num_start&#45;&gt;num_accept -->
<g id="edge3" class="edge">
<title>num_start-&gt;num_accept</title>
<path fill="none" stroke="black" d="M58.71,-180C74.77,-180 97.54,-180 116.83,-180"></path>
<polygon fill="black" stroke="black" points="116.78,-183.5 126.78,-180 116.78,-176.5 116.78,-183.5"></polygon>
<text text-anchor="middle" x="93.45" y="-184.2" font-family="Times,serif" font-size="14.00">digit</text>
</g>
<!-- num_accept&#45;&gt;num_accept -->
<g id="edge4" class="edge">
<title>num_accept-&gt;num_accept</title>
<path fill="none" stroke="black" d="M146.58,-205.8C146.08,-216.15 148.98,-224.84 155.26,-224.84 158.99,-224.84 161.52,-221.78 162.86,-217.12"></path>
<polygon fill="black" stroke="black" points="166.33,-217.6 163.8,-207.31 159.36,-216.93 166.33,-217.6"></polygon>
<text text-anchor="middle" x="155.26" y="-229.04" font-family="Times,serif" font-size="14.00">digit</text>
</g>
<!-- num_dot -->
<g id="node5" class="node">
<title>num_dot</title>
<ellipse fill="none" stroke="black" cx="239.61" cy="-180" rx="18.01" ry="18.01"></ellipse>
<text text-anchor="middle" x="239.61" y="-175.8" font-family="Times,serif" font-size="14.00">D</text>
</g>
<!-- num_accept&#45;&gt;num_dot -->
<g id="edge5" class="edge">
<title>num_accept-&gt;num_dot</title>
<path fill="none" stroke="black" d="M182.31,-180C191.06,-180 200.86,-180 209.81,-180"></path>
<polygon fill="black" stroke="black" points="209.78,-183.5 219.78,-180 209.78,-176.5 209.78,-183.5"></polygon>
<text text-anchor="middle" x="201.85" y="-184.2" font-family="Times,serif" font-size="14.00">.</text>
</g>
<!-- num_frac -->
<g id="node6" class="node">
<title>num_frac</title>
<ellipse fill="none" stroke="black" cx="341.29" cy="-180" rx="18" ry="18"></ellipse>
<ellipse fill="none" stroke="black" cx="341.29" cy="-180" rx="22" ry="22"></ellipse>
<text text-anchor="middle" x="341.29" y="-175.8" font-family="Times,serif" font-size="14.00">F</text>
</g>
<!-- num_dot&#45;&gt;num_frac -->
<g id="edge6" class="edge">
<title>num_dot-&gt;num_frac</title>
<path fill="none" stroke="black" d="M257.97,-180C271.61,-180 291.01,-180 307.55,-180"></path>
<polygon fill="black" stroke="black" points="307.45,-183.5 317.45,-180 307.45,-176.5 307.45,-183.5"></polygon>
<text text-anchor="middle" x="288.45" y="-184.2" font-family="Times,serif" font-size="14.00">digit</text>
</g>
<!-- num_frac&#45;&gt;num_frac -->
<g id="edge7" class="edge">
<title>num_frac-&gt;num_frac</title>
<path fill="none" stroke="black" d="M331.73,-200.17C330.26,-210.6 333.44,-220 341.29,-220 346.07,-220 349.12,-216.51 350.44,-211.42"></path>
<polygon fill="black" stroke="black" points="353.92,-211.8 350.79,-201.68 346.93,-211.55 353.92,-211.8"></polygon>
<text text-anchor="middle" x="341.29" y="-224.2" font-family="Times,serif" font-size="14.00">digit</text>
</g>
<!-- op_start -->
<g id="node7" class="node">
<title>op_start</title>
<ellipse fill="none" stroke="black" cx="37.24" cy="-317" rx="21.24" ry="21.24"></ellipse>
<text text-anchor="middle" x="37.24" y="-312.8" font-family="Times,serif" font-size="14.00">S3</text>
</g>
<!-- op_accept -->
<g id="node8" class="node">
<title>op_accept</title>
<ellipse fill="none" stroke="black" cx="155.26" cy="-317" rx="22.84" ry="22.84"></ellipse>
<ellipse fill="none" stroke="black" cx="155.26" cy="-317" rx="26.84" ry="26.84"></ellipse>
<text text-anchor="middle" x="155.26" y="-312.8" font-family="Times,serif" font-size="14.00">A3</text>
</g>
<!-- op_start&#45;&gt;op_accept -->
<g id="edge8" class="edge">
<title>op_start-&gt;op_accept</title>
<path fill="none" stroke="black" d="M58.71,-317C74.77,-317 97.54,-317 116.83,-317"></path>
<polygon fill="black" stroke="black" points="116.78,-320.5 126.78,-317 116.78,-313.5 116.78,-320.5"></polygon>
<text text-anchor="middle" x="93.45" y="-321.2" font-family="Times,serif" font-size="14.00">+,-,*,/</text>
</g>
</g>
</svg>
</p></li>
<li>
<p>增加初态，合并状态转换图</p>
<p class="dot"><!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<!-- Generated by graphviz version 9.0.0 (20230911.1827)
 -->
<!-- Title: MergedDFA Pages: 1 -->
<svg width="480pt" height="294pt" viewBox="0.00 0.00 479.79 294.41" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 290.41)">
<title>MergedDFA</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-290.41 475.79,-290.41 475.79,4 -4,4"></polygon>
<!-- start -->
<g id="node1" class="node">
<title>start</title>
<ellipse fill="none" stroke="black" cx="41.62" cy="-110.38" rx="41.62" ry="41.62"></ellipse>
<text text-anchor="middle" x="41.62" y="-106.18" font-family="Times,serif" font-size="14.00">START</text>
</g>
<!-- id_accept -->
<g id="node2" class="node">
<title>id_accept</title>
<ellipse fill="none" stroke="black" cx="190.76" cy="-226.38" rx="21.23" ry="21.23"></ellipse>
<ellipse fill="none" stroke="black" cx="190.76" cy="-226.38" rx="25.23" ry="25.23"></ellipse>
<text text-anchor="middle" x="190.76" y="-222.18" font-family="Times,serif" font-size="14.00">ID</text>
</g>
<!-- start&#45;&gt;id_accept -->
<g id="edge1" class="edge">
<title>start-&gt;id_accept</title>
<path fill="none" stroke="black" d="M74.91,-135.84C100.86,-156.3 136.95,-184.75 161.71,-204.27"></path>
<polygon fill="black" stroke="black" points="159.39,-206.9 169.41,-210.34 163.72,-201.4 159.39,-206.9"></polygon>
<text text-anchor="middle" x="118.21" y="-185.58" font-family="Times,serif" font-size="14.00">letter</text>
</g>
<!-- num_accept -->
<g id="node3" class="node">
<title>num_accept</title>
<ellipse fill="none" stroke="black" cx="190.76" cy="-110.38" rx="33.57" ry="33.57"></ellipse>
<ellipse fill="none" stroke="black" cx="190.76" cy="-110.38" rx="37.57" ry="37.57"></ellipse>
<text text-anchor="middle" x="190.76" y="-106.18" font-family="Times,serif" font-size="14.00">NUM</text>
</g>
<!-- start&#45;&gt;num_accept -->
<g id="edge2" class="edge">
<title>start-&gt;num_accept</title>
<path fill="none" stroke="black" d="M83.61,-110.38C101.63,-110.38 122.93,-110.38 141.7,-110.38"></path>
<polygon fill="black" stroke="black" points="141.5,-113.88 151.49,-110.38 141.49,-106.88 141.5,-113.88"></polygon>
<text text-anchor="middle" x="118.21" y="-114.58" font-family="Times,serif" font-size="14.00">digit</text>
</g>
<!-- op_accept -->
<g id="node6" class="node">
<title>op_accept</title>
<ellipse fill="none" stroke="black" cx="190.76" cy="-27.38" rx="23.38" ry="23.38"></ellipse>
<ellipse fill="none" stroke="black" cx="190.76" cy="-27.38" rx="27.38" ry="27.38"></ellipse>
<text text-anchor="middle" x="190.76" y="-23.18" font-family="Times,serif" font-size="14.00">OP</text>
</g>
<!-- start&#45;&gt;op_accept -->
<g id="edge3" class="edge">
<title>start-&gt;op_accept</title>
<path fill="none" stroke="black" d="M78.24,-90.29C102.09,-76.83 133.28,-59.24 156.61,-46.08"></path>
<polygon fill="black" stroke="black" points="158.09,-49.26 165.08,-41.3 154.65,-43.17 158.09,-49.26"></polygon>
<text text-anchor="middle" x="118.21" y="-80.58" font-family="Times,serif" font-size="14.00">+,-,*,/</text>
</g>
<!-- id_accept&#45;&gt;id_accept -->
<g id="edge4" class="edge">
<title>id_accept-&gt;id_accept</title>
<path fill="none" stroke="black" d="M180.22,-249.51C179.07,-260.23 182.59,-269.61 190.76,-269.61 195.74,-269.61 198.99,-266.13 200.51,-260.98"></path>
<polygon fill="black" stroke="black" points="204,-261.23 201.19,-251.02 197.01,-260.75 204,-261.23"></polygon>
<text text-anchor="middle" x="190.76" y="-273.81" font-family="Times,serif" font-size="14.00">letter,digit</text>
</g>
<!-- num_accept&#45;&gt;num_accept -->
<g id="edge5" class="edge">
<title>num_accept-&gt;num_accept</title>
<path fill="none" stroke="black" d="M180.03,-146.73C180.35,-157.54 183.93,-165.95 190.76,-165.95 194.92,-165.95 197.87,-162.83 199.62,-157.94"></path>
<polygon fill="black" stroke="black" points="203.05,-158.66 201.23,-148.22 196.14,-157.51 203.05,-158.66"></polygon>
<text text-anchor="middle" x="190.76" y="-170.15" font-family="Times,serif" font-size="14.00">digit</text>
</g>
<!-- num_dot -->
<g id="node4" class="node">
<title>num_dot</title>
<ellipse fill="none" stroke="black" cx="298.71" cy="-110.38" rx="30.88" ry="30.88"></ellipse>
<text text-anchor="middle" x="298.71" y="-106.18" font-family="Times,serif" font-size="14.00">DOT</text>
</g>
<!-- num_accept&#45;&gt;num_dot -->
<g id="edge6" class="edge">
<title>num_accept-&gt;num_dot</title>
<path fill="none" stroke="black" d="M228.82,-110.38C237.61,-110.38 247.05,-110.38 256.04,-110.38"></path>
<polygon fill="black" stroke="black" points="255.99,-113.88 265.99,-110.38 255.99,-106.88 255.99,-113.88"></polygon>
<text text-anchor="middle" x="248.08" y="-114.58" font-family="Times,serif" font-size="14.00">.</text>
</g>
<!-- num_frac -->
<g id="node5" class="node">
<title>num_frac</title>
<ellipse fill="none" stroke="black" cx="431.53" cy="-110.38" rx="36.26" ry="36.26"></ellipse>
<ellipse fill="none" stroke="black" cx="431.53" cy="-110.38" rx="40.26" ry="40.26"></ellipse>
<text text-anchor="middle" x="431.53" y="-106.18" font-family="Times,serif" font-size="14.00">FRAC</text>
</g>
<!-- num_dot&#45;&gt;num_frac -->
<g id="edge7" class="edge">
<title>num_dot-&gt;num_frac</title>
<path fill="none" stroke="black" d="M330.05,-110.38C344.77,-110.38 362.85,-110.38 379.6,-110.38"></path>
<polygon fill="black" stroke="black" points="379.41,-113.88 389.41,-110.38 379.41,-106.88 379.41,-113.88"></polygon>
<text text-anchor="middle" x="360.43" y="-114.58" font-family="Times,serif" font-size="14.00">digit</text>
</g>
<!-- num_frac&#45;&gt;num_frac -->
<g id="edge8" class="edge">
<title>num_frac-&gt;num_frac</title>
<path fill="none" stroke="black" d="M418.24,-148.76C418.7,-159.97 423.13,-168.64 431.53,-168.64 436.78,-168.64 440.48,-165.25 442.63,-159.98"></path>
<polygon fill="black" stroke="black" points="446.04,-160.74 444.53,-150.25 439.17,-159.39 446.04,-160.74"></polygon>
<text text-anchor="middle" x="431.53" y="-172.84" font-family="Times,serif" font-size="14.00">digit</text>
</g>
</g>
</svg>
</p></li>
<li>
<p>化简状态转换图<br>
需要检查状态的等价性，考虑的因素包括：</p>
<ol>
<li>状态的类型（接受/非接受）</li>
<li>输入字符的转换目标状态</li>
<li>语义动作的一致性</li>
</ol>
<p>例如，对于浮点数识别中的状态：</p>
<p class="dot"><!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<!-- Generated by graphviz version 9.0.0 (20230911.1827)
 -->
<!-- Title: MinDFA Pages: 1 -->
<svg width="259pt" height="87pt" viewBox="0.00 0.00 258.84 86.80" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 82.8)">
<title>MinDFA</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-82.8 254.84,-82.8 254.84,4 -4,4"></polygon>
<!-- start -->
<g id="node1" class="node">
<title>start</title>
<ellipse fill="none" stroke="black" cx="18" cy="-22" rx="18" ry="18"></ellipse>
<text text-anchor="middle" x="18" y="-17.8" font-family="Times,serif" font-size="14.00">S</text>
</g>
<!-- int_part -->
<g id="node2" class="node">
<title>int_part</title>
<ellipse fill="none" stroke="black" cx="119.67" cy="-22" rx="18" ry="18"></ellipse>
<ellipse fill="none" stroke="black" cx="119.67" cy="-22" rx="22" ry="22"></ellipse>
<text text-anchor="middle" x="119.67" y="-17.8" font-family="Times,serif" font-size="14.00">I</text>
</g>
<!-- start&#45;&gt;int_part -->
<g id="edge1" class="edge">
<title>start-&gt;int_part</title>
<path fill="none" stroke="black" d="M36.36,-22C50,-22 69.4,-22 85.94,-22"></path>
<polygon fill="black" stroke="black" points="85.84,-25.5 95.84,-22 85.84,-18.5 85.84,-25.5"></polygon>
<text text-anchor="middle" x="66.83" y="-26.2" font-family="Times,serif" font-size="14.00">digit</text>
</g>
<!-- int_part&#45;&gt;int_part -->
<g id="edge2" class="edge">
<title>int_part-&gt;int_part</title>
<path fill="none" stroke="black" d="M110.11,-42.17C108.64,-52.6 111.83,-62 119.67,-62 124.45,-62 127.5,-58.51 128.82,-53.42"></path>
<polygon fill="black" stroke="black" points="132.31,-53.8 129.17,-43.68 125.31,-53.55 132.31,-53.8"></polygon>
<text text-anchor="middle" x="119.67" y="-66.2" font-family="Times,serif" font-size="14.00">digit</text>
</g>
<!-- frac_part -->
<g id="node3" class="node">
<title>frac_part</title>
<ellipse fill="none" stroke="black" cx="228.84" cy="-22" rx="18" ry="18"></ellipse>
<ellipse fill="none" stroke="black" cx="228.84" cy="-22" rx="22" ry="22"></ellipse>
<text text-anchor="middle" x="228.84" y="-17.8" font-family="Times,serif" font-size="14.00">F</text>
</g>
<!-- int_part&#45;&gt;frac_part -->
<g id="edge3" class="edge">
<title>int_part-&gt;frac_part</title>
<path fill="none" stroke="black" d="M142.1,-22C157.29,-22 177.94,-22 195.17,-22"></path>
<polygon fill="black" stroke="black" points="194.93,-25.5 204.93,-22 194.93,-18.5 194.93,-25.5"></polygon>
<text text-anchor="middle" x="174.25" y="-26.2" font-family="Times,serif" font-size="14.00">.digit</text>
</g>
<!-- frac_part&#45;&gt;frac_part -->
<g id="edge4" class="edge">
<title>frac_part-&gt;frac_part</title>
<path fill="none" stroke="black" d="M218.96,-42.17C217.44,-52.6 220.74,-62 228.84,-62 233.78,-62 236.93,-58.51 238.29,-53.42"></path>
<polygon fill="black" stroke="black" points="241.78,-53.81 238.66,-43.68 234.78,-53.54 241.78,-53.81"></polygon>
<text text-anchor="middle" x="228.84" y="-66.2" font-family="Times,serif" font-size="14.00">digit</text>
</g>
</g>
</svg>
</p><p>这里的<code>int_part</code>和<code>frac_part</code>虽然都是接受状态，但由于语义动作不同（一个返回整数token，一个返回浮点数token），所以不能合并。</p>
</li>
<li>
<p>增加出错处理终态</p>
<p class="dot"><!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<!-- Generated by graphviz version 9.0.0 (20230911.1827)
 -->
<!-- Title: ErrorDFA Pages: 1 -->
<svg width="428pt" height="328pt" viewBox="0.00 0.00 427.82 328.23" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 324.23)">
<title>ErrorDFA</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-324.23 423.82,-324.23 423.82,4 -4,4"></polygon>
<!-- start -->
<g id="node1" class="node">
<title>start</title>
<ellipse fill="none" stroke="black" cx="41.62" cy="-81.21" rx="41.62" ry="41.62"></ellipse>
<text text-anchor="middle" x="41.62" y="-77.01" font-family="Times,serif" font-size="14.00">START</text>
</g>
<!-- id -->
<g id="node2" class="node">
<title>id</title>
<ellipse fill="none" stroke="black" cx="190.76" cy="-260.21" rx="21.23" ry="21.23"></ellipse>
<ellipse fill="none" stroke="black" cx="190.76" cy="-260.21" rx="25.23" ry="25.23"></ellipse>
<text text-anchor="middle" x="190.76" y="-256.01" font-family="Times,serif" font-size="14.00">ID</text>
</g>
<!-- start&#45;&gt;id -->
<g id="edge1" class="edge">
<title>start-&gt;id</title>
<path fill="none" stroke="black" d="M66.28,-114.95C87.78,-144.88 120.99,-189.31 153.19,-225.21 156.36,-228.74 159.81,-232.34 163.3,-235.82"></path>
<polygon fill="black" stroke="black" points="160.66,-238.13 170.27,-242.59 165.53,-233.11 160.66,-238.13"></polygon>
<text text-anchor="middle" x="118.21" y="-206.41" font-family="Times,serif" font-size="14.00">letter</text>
</g>
<!-- num -->
<g id="node3" class="node">
<title>num</title>
<ellipse fill="none" stroke="black" cx="190.76" cy="-144.21" rx="33.57" ry="33.57"></ellipse>
<ellipse fill="none" stroke="black" cx="190.76" cy="-144.21" rx="37.57" ry="37.57"></ellipse>
<text text-anchor="middle" x="190.76" y="-140.01" font-family="Times,serif" font-size="14.00">NUM</text>
</g>
<!-- start&#45;&gt;num -->
<g id="edge2" class="edge">
<title>start-&gt;num</title>
<path fill="none" stroke="black" d="M80.13,-97.27C100,-105.77 124.52,-116.27 145.34,-125.19"></path>
<polygon fill="black" stroke="black" points="143.88,-128.37 154.45,-129.09 146.63,-121.93 143.88,-128.37"></polygon>
<text text-anchor="middle" x="118.21" y="-123.41" font-family="Times,serif" font-size="14.00">digit</text>
</g>
<!-- op -->
<g id="node4" class="node">
<title>op</title>
<ellipse fill="none" stroke="black" cx="190.76" cy="-61.21" rx="23.38" ry="23.38"></ellipse>
<ellipse fill="none" stroke="black" cx="190.76" cy="-61.21" rx="27.38" ry="27.38"></ellipse>
<text text-anchor="middle" x="190.76" y="-57.01" font-family="Times,serif" font-size="14.00">OP</text>
</g>
<!-- start&#45;&gt;op -->
<g id="edge3" class="edge">
<title>start-&gt;op</title>
<path fill="none" stroke="black" d="M83.22,-75.69C104.65,-72.78 130.79,-69.22 151.81,-66.36"></path>
<polygon fill="black" stroke="black" points="152.27,-69.83 161.71,-65.02 151.33,-62.9 152.27,-69.83"></polygon>
<text text-anchor="middle" x="118.21" y="-77.41" font-family="Times,serif" font-size="14.00">+,-,*,/</text>
</g>
<!-- error -->
<g id="node5" class="node">
<title>error</title>
<ellipse fill="lightgray" stroke="black" cx="372.59" cy="-144.21" rx="43.23" ry="43.23"></ellipse>
<ellipse fill="none" stroke="black" cx="372.59" cy="-144.21" rx="47.23" ry="47.23"></ellipse>
<text text-anchor="middle" x="372.59" y="-140.01" font-family="Times,serif" font-size="14.00">ERROR</text>
</g>
<!-- start&#45;&gt;error -->
<g id="edge4" class="edge">
<title>start-&gt;error</title>
<path fill="none" stroke="black" d="M73.45,-53.76C94.34,-37.07 123.47,-17.31 153.19,-8.41 185.18,1.18 197.31,3.96 228.33,-8.41 272.99,-26.21 311.73,-65.29 337.62,-96.98"></path>
<polygon fill="black" stroke="black" points="334.66,-98.88 343.64,-104.51 340.13,-94.51 334.66,-98.88"></polygon>
<text text-anchor="middle" x="190.76" y="-13.41" font-family="Times,serif" font-size="14.00">other</text>
</g>
<!-- id&#45;&gt;id -->
<g id="edge5" class="edge">
<title>id-&gt;id</title>
<path fill="none" stroke="black" d="M177.63,-282C175.62,-293.27 179.99,-303.43 190.76,-303.43 197.66,-303.43 201.93,-299.26 203.58,-293.3"></path>
<polygon fill="black" stroke="black" points="207.07,-293.61 203.84,-283.52 200.08,-293.42 207.07,-293.61"></polygon>
<text text-anchor="middle" x="190.76" y="-307.63" font-family="Times,serif" font-size="14.00">letter,digit</text>
</g>
<!-- id&#45;&gt;error -->
<g id="edge6" class="edge">
<title>id-&gt;error</title>
<path fill="none" stroke="black" d="M212.39,-246.9C239.15,-229.64 286.69,-198.97 322.87,-175.63"></path>
<polygon fill="black" stroke="black" points="324.5,-178.75 331,-170.38 320.7,-172.86 324.5,-178.75"></polygon>
<text text-anchor="middle" x="276.84" y="-226.41" font-family="Times,serif" font-size="14.00">other</text>
</g>
<!-- num&#45;&gt;num -->
<g id="edge7" class="edge">
<title>num-&gt;num</title>
<path fill="none" stroke="black" d="M177.16,-179.75C177.37,-190.94 181.9,-199.78 190.76,-199.78 196.29,-199.78 200.14,-196.33 202.3,-191.01"></path>
<polygon fill="black" stroke="black" points="205.73,-191.7 204.08,-181.24 198.84,-190.44 205.73,-191.7"></polygon>
<text text-anchor="middle" x="190.76" y="-203.98" font-family="Times,serif" font-size="14.00">digit</text>
</g>
<!-- num&#45;&gt;error -->
<g id="edge8" class="edge">
<title>num-&gt;error</title>
<path fill="none" stroke="black" d="M228.58,-144.21C253.06,-144.21 285.71,-144.21 313.63,-144.21"></path>
<polygon fill="black" stroke="black" points="313.36,-147.71 323.36,-144.21 313.36,-140.71 313.36,-147.71"></polygon>
<text text-anchor="middle" x="276.84" y="-148.41" font-family="Times,serif" font-size="14.00">letter,other</text>
</g>
<!-- error&#45;&gt;error -->
<g id="edge9" class="edge">
<title>error-&gt;error</title>
<path fill="none" stroke="black" d="M354.77,-188.41C355.71,-200.36 361.65,-209.44 372.59,-209.44 379.77,-209.44 384.79,-205.53 387.66,-199.46"></path>
<polygon fill="black" stroke="black" points="391.03,-200.43 390.04,-189.88 384.24,-198.75 391.03,-200.43"></polygon>
<text text-anchor="middle" x="372.59" y="-213.64" font-family="Times,serif" font-size="14.00">any</text>
</g>
</g>
</svg>
</p></li>
</ol>
<p>将这些思想实现在LEX程序中：</p>
<pre data-role="codeBlock" data-info="lex" class="language-lex lex"><code>%{
#include &lt;stdio.h&gt;
#define TOK_ID    1
#define TOK_INT   2
#define TOK_FLOAT 3
#define TOK_OP    4
#define TOK_ERROR 5
%}

/* 定义正则表达式 */
digit    [0-9]
letter   [a-zA-Z]
op       [+\-*/]

%%
{letter}({letter}|{digit})*    { 
    /* 标识符的语义动作 */
    printf("ID: %s\n", yytext);
    return TOK_ID;
}

{digit}+    { 
    /* 整数的语义动作 */
    printf("INT: %s\n", yytext);
    return TOK_INT;
}

{digit}+\.{digit}+    { 
    /* 浮点数的语义动作 */
    printf("FLOAT: %s\n", yytext);
    return TOK_FLOAT;
}

{op}    { 
    /* 运算符的语义动作 */
    printf("OP: %s\n", yytext);
    return TOK_OP;
}

[ \t\n]    { /* 忽略空白字符 */ }

.    { 
    /* 错误处理 */
    printf("Error: unexpected character %s\n", yytext);
    return TOK_ERROR;
}

%%

int main() {
    int token;
    while ((token = yylex()) != 0) {
        // 处理token
    }
    return 0;
}

int yywrap() {
    return 1;
}
</code></pre><p>LEX构造过程的几个重要原则：</p>
<ol>
<li>
<p>最长匹配原则</p>
<ul>
<li>当多个模式都能匹配时，选择最长的匹配</li>
</ul>
<pre data-role="codeBlock" data-info="lex" class="language-lex lex"><code>"if"      { return IF; }         // 优先匹配关键字
[a-z]+    { return ID; }         // 其次匹配标识符
</code></pre></li>
<li>
<p>优先级原则</p>
<ul>
<li>当多个模式匹配相同长度的输入时，选择在规则部分先出现的模式</li>
</ul>
<pre data-role="codeBlock" data-info="lex" class="language-lex lex"><code>"=="    { return EQ; }          // 优先匹配"=="
"="     { return ASSIGN; }      // 其次匹配"="
</code></pre></li>
<li>
<p>错误恢复策略</p>
<ul>
<li>定义清晰的错误状态和处理方法</li>
<li>提供适当的错误信息</li>
<li>确保词法分析器能够从错误中恢复并继续处理后续输入</li>
</ul>
</li>
<li>
<p>状态管理</p>
<ul>
<li>使用起始条件来处理上下文相关的词法规则</li>
<li>合理设计状态转换以处理复杂的词法结构</li>
</ul>
</li>
</ol>
<p>这种构造思想使得LEX能够：</p>
<ol>
<li>自动处理词法分析中的回溯问题</li>
<li>高效地实现最长匹配原则</li>
<li>正确处理词法规则的优先级</li>
<li>提供灵活的错误处理机制</li>
</ol>
<hr>
<p>词法分析程序的这两种处理结构各有特点，我来详细解释一下。</p>
<p>作为主程序的单趟扫描方式（One-Pass Scanner）：<br>
这种方式下，词法分析器独立运行，一次性扫描整个源文件，生成所有词法单元。它会把结果存储在文件或内存中，供语法分析器后续使用。处理过程类似这样：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">scan_source_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Token token<span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_end_of_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        token <span class="token operator">=</span> <span class="token function">get_next_token</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">write_token_to_buffer</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>这种方式的特点是：词法分析完全独立，会一次性处理所有输入。比如，如果源代码是：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>它会一次性生成类似这样的词法单元序列：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>&lt;KEYWORD, "int"&gt;
&lt;ID, "main"&gt;
&lt;LPAREN, "("&gt;
&lt;RPAREN, ")"&gt;
&lt;LBRACE, "{"&gt;
&lt;KEYWORD, "return"&gt;
&lt;NUMBER, "0"&gt;
&lt;SEMICOLON, ";"&gt;
&lt;RBRACE, "}"&gt;
</code></pre><p>作为子程序的按需扫描方式（On-Demand Scanner）：<br>
这种方式下，词法分析器被设计为一个子程序，由语法分析器调用。每当语法分析器需要下一个词法单元时，就调用词法分析器。典型的接口是这样的：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-struct">struct</span> <span class="token punctuation">{</span>
    TokenType type<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>lexeme<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> line<span class="token punctuation">;</span>
    <span class="token comment">// 其他属性...</span>
<span class="token punctuation">}</span> Token<span class="token punctuation">;</span>

Token <span class="token function">get_next_token</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Token token<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> c<span class="token punctuation">;</span>
    
    <span class="token comment">// 跳过空白字符</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token function">get_next_char</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">' '</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">'\t'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 更新行号等信息</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 识别词法单元</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        token <span class="token operator">=</span> <span class="token function">scan_number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">isalpha</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        token <span class="token operator">=</span> <span class="token function">scan_identifier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
        token <span class="token operator">=</span> <span class="token function">scan_operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword keyword-return">return</span> token<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>语法分析器会这样使用它：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">parse_expression</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Token token <span class="token operator">=</span> <span class="token function">get_next_token</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-switch">switch</span> <span class="token punctuation">(</span>token<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-case">case</span> ID<span class="token operator">:</span>
            <span class="token function">parse_identifier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-case">case</span> NUMBER<span class="token operator">:</span>
            <span class="token function">parse_number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
        <span class="token comment">// 处理其他情况...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>两种方式的对比：</p>
<ol>
<li>
<p>单趟扫描方式：</p>
<ul>
<li>优点：
<ul>
<li>实现简单直观</li>
<li>可以方便地进行词法错误的统计和报告</li>
<li>便于调试，因为可以看到完整的词法单元序列</li>
</ul>
</li>
<li>缺点：
<ul>
<li>需要额外的存储空间保存词法单元序列</li>
<li>可能处理了不需要的输入（比如有语法错误时）</li>
<li>不适合交互式环境</li>
</ul>
</li>
</ul>
</li>
<li>
<p>按需扫描方式：</p>
<ul>
<li>优点：
<ul>
<li>内存效率高，不需要存储整个词法单元序列</li>
<li>发现语法错误时可以立即停止</li>
<li>适合交互式环境和增量编译</li>
</ul>
</li>
<li>缺点：
<ul>
<li>实现相对复杂</li>
<li>需要保持扫描器的状态</li>
<li>错误恢复可能更困难</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>选择哪种方式主要取决于具体需求：</p>
<ol>
<li>如果是编写一个简单的编译器或者用于教学目的，单趟扫描方式更合适</li>
<li>如果是实现一个现代IDE的语法高亮功能，按需扫描方式更合适</li>
<li>如果要处理大型源文件，按需扫描方式的内存效率更高</li>
<li>如果需要支持错误恢复和重新扫描，单趟扫描方式更容易实现</li>
</ol>
<p>实际上，很多现代编译器会采用混合方式，在保持按需扫描灵活性的同时，使用缓存来提高性能。这样可以在必要时重新扫描某些部分，又不会完全失去词法分析的中间结果。</p>
<hr>
<p>确实，这些都是单趟扫描方式的重要特点。我来详细解释一下：</p>
<ol>
<li>
<p>降低Parser复杂性，使编译器结构更清晰：</p>
<ul>
<li>Parser不需要关心字符级的处理细节，专注于语法分析</li>
<li>词法规则和语法规则完全分离，便于维护和修改</li>
<li>比如处理这样的代码：<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-for">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>MAX_LENGTH<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
</code></pre></li>
<li>Scanner会处理所有的细节，Parser只需要处理类似这样的token序列：<pre data-role="codeBlock" data-info="" class="language-text"><code>&lt;FOR&gt; &lt;LPAREN&gt; &lt;ID,"i"&gt; &lt;ASSIGN&gt; &lt;NUMBER,"0"&gt; &lt;SEMICOLON&gt; ...
</code></pre></li>
</ul>
</li>
<li>
<p>统一的属性字形式提高可移植性：</p>
<ul>
<li>源代码中的所有词素都被转换成统一的内部表示</li>
<li>不同平台的字符集差异被屏蔽</li>
<li>例如关键字<code>if</code>会被转换成类似这样的属性字：<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-struct">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> token_type<span class="token punctuation">;</span>    <span class="token comment">// 如TOKEN_IF</span>
    <span class="token keyword keyword-union">union</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-int">int</span> int_value<span class="token punctuation">;</span>
        <span class="token keyword keyword-float">float</span> float_value<span class="token punctuation">;</span>
        <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>string_value<span class="token punctuation">;</span>
        <span class="token comment">// 其他可能的属性...</span>
    <span class="token punctuation">}</span> attribute<span class="token punctuation">;</span>
<span class="token punctuation">}</span> Token<span class="token punctuation">;</span>
</code></pre></li>
</ul>
</li>
<li>
<p>分开构造Scanner/Parser生成器的优势：</p>
<ul>
<li>Scanner可以用<code>lex</code>/<code>flex</code>生成</li>
<li>Parser可以用<code>yacc</code>/<code>bison</code>生成</li>
<li>两者通过标准接口配合：<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">/* scanner.l */</span>
<span class="token operator">%</span><span class="token operator">%</span>
<span class="token keyword keyword-if">if</span>      <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> IF<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token operator">+</span>  <span class="token punctuation">{</span> yylval <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>yytext<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword keyword-return">return</span> NUMBER<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token comment">/* parser.y */</span>
<span class="token operator">%</span><span class="token operator">%</span>
stmt<span class="token operator">:</span> IF <span class="token char">'('</span> expr <span class="token char">')'</span> stmt
    <span class="token operator">|</span> expr <span class="token char">';'</span>
    <span class="token punctuation">;</span>
</code></pre></li>
</ul>
</li>
<li>
<p>存储和调度开销：</p>
<ul>
<li>需要额外的存储空间：<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TOKEN_BUFFER_SIZE</span> <span class="token expression"><span class="token number">1024</span></span></span>
Token token_buffer<span class="token punctuation">[</span>TOKEN_BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> token_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">store_token</span><span class="token punctuation">(</span>Token t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>token_count <span class="token operator">&lt;</span> TOKEN_BUFFER_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        token_buffer<span class="token punctuation">[</span>token_count<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 处理缓冲区溢出</span>
        <span class="token function">flush_token_buffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></li>
<li>当内存不足时需要进行内外存交换：<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">flush_token_buffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">write_tokens_to_file</span><span class="token punctuation">(</span>token_buffer<span class="token punctuation">,</span> token_count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    token_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Token <span class="token function">get_token</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> token_count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">load_tokens_from_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> token_buffer<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li>
</ul>
</li>
</ol>
<p>这些特点使得单趟扫描方式特别适合构建传统的批处理式编译器。但在现代IDE环境中，这些优势可能变成劣势：</p>
<ol>
<li>统一的属性字形式可能丢失源代码的一些细节，而这些细节对IDE的代码分析功能很重要</li>
<li>存储开销在处理大型项目时可能成为性能瓶颈</li>
<li>批处理式的设计不利于实现增量编译和实时语法检查</li>
</ol>
<p>因此，现代编译器可能会采用更灵活的设计，比如：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>class ModernScanner <span class="token punctuation">{</span>
    <span class="token comment">// 支持增量扫描</span>
    Token<span class="token operator">*</span> <span class="token function">scan_region</span><span class="token punctuation">(</span>SourceLocation start<span class="token punctuation">,</span> SourceLocation end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 保留源代码信息</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">TokenInfo</span> <span class="token punctuation">{</span>
        Token token<span class="token punctuation">;</span>
        SourceRange range<span class="token punctuation">;</span>
        <span class="token comment">// 其他元信息</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 支持撤销和重做</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">invalidate_region</span><span class="token punctuation">(</span>SourceLocation start<span class="token punctuation">,</span> SourceLocation end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">revalidate_region</span><span class="token punctuation">(</span>SourceLocation start<span class="token punctuation">,</span> SourceLocation end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>这种设计既保留了单趟扫描的优点，又能满足现代开发环境的需求。</p>

      </div>
      
      
    
    
    
    
    
    
  
    </body></html>